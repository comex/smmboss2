<script>
function assert(x) {
  if (!(x)) {
    throw new Error('assertion failed');
  }
}
function sleep(n) {
  let { promise, resolve, reject } = Promise.withResolvers();
  setTimeout(resolve, n);
  return promise;
}

class Cond {
  constructor() {
    this.waiters = [];
  }
  broadcast() {
    for (let waiter of this.waiters) {
      waiter();
    }
  }
  wait() {
    let { promise, resolve, reject } = Promise.withResolvers();
    this.waiters.push(resolve);
    return promise;
  }
  then(f, r) {
    return this.wait().then(f, r);
  }
}

class Lock {
  constructor() {
    this.locked = false;
    this.waiters = [];
  };
  lock() {
    if (!this.locked) {
      this.locked = true;
      return Promise.resolve(undefined);
    } else {
      let { promise, resolve, reject } = Promise.withResolvers();
      this.waiters.push(resolve);
      return promise;
    }
  }
  unlock() {
    assert(this.locked);
    this.locked = false;
    let resolve = this.waiters.shift();
    if (resolve !== undefined) {
      resolve();
    }
  }
  async with(cb) {
    console.log('with entry');
    await this.lock();
    console.log('with got lock');
    let isUnlocked = false;
    let unlock = () => {
      if (!isUnlocked) {
        isUnlocked = true;
        this.unlock();
      }
    };
    try {
      return await cb(unlock);
    } finally {
      unlock();
    }
  }
}

class Throttle {
  constructor(name, defaultDelay = 100) {
    this.defaultDelay = defaultDelay;
    this.name = name;
    this.reset();
  }
  reset() {
    this.delay = this.defaultDelay;
  }
  then(f, r) {
    let delay = this.delay;
    this.delay *= 2;
    console.log(`Throttle "${this.name}" waiting for ${delay} ms`);
    return sleep(delay).then(f, r);
  }
}

class WSWrapper {
  constructor(url, delegate) {
    this.wsURL = url;
    this.delegate = delegate;
    this.openThrottle = new Throttle('open');
    this.state = 'idle';
    this.ws = null;
    this.wantOpen = false;
  }
  setWantOpen(wantOpen) {
    this.wantOpen = wantOpen;
    this.openCloseWSAsNeeded();
  }
  openCloseWSAsNeeded() {
    if (this.state == 'idle' && this.wantOpen) {
      this.openWS();
    } else if (this.state == 'open' && !this.wantOpen) {
      console.log(`closing ${this.wsURL}`);
      this.ws.close();
    }
  }
  openWS() {
    assert(this.ws === null);
    assert(this.state == 'idle');
    console.log(`connecting to ${this.wsURL}`);
    let ws = new WebSocket(this.wsURL);
    this.ws = ws;
    this.state = 'connecting';
    ws.binaryType = 'arraybuffer';
    ws.onopen = (e) => {
      assert(this.ws === ws);
      this.state = 'open';
      console.log(`opened connection to ${this.wsURL}`);
      this.delegate.onOpen(e);
      // if it doesn't close quickly, then reset throttle
      setTimeout(() => {
        if (this.ws === ws) {
          this.openThrottle.reset();
        }
      }, 1000);
    };
    ws.onmessage = (e) => {
      assert(this.ws === ws);
      this.delegate.onMessage(e);
    };
    ws.onclose = (e) => {
      assert(this.ws === ws);
      console.log(`closed connection to ${this.wsURL}`);
      this.ws = null;
      if (this.wantOpen) {
        this.state = 'openThrottle';
        (async () => {
          await this.openThrottle;
          this.state = 'idle';
          this.openCloseWSAsNeeded();
        })();
      } else {
        this.state = 'idle';
      }
      this.delegate.onClose(e);
    };
  }
}

class RPCConn {
  constructor(baseURL) {
    this.wsw = new WSWrapper(`${baseURL}/ws/rpc`, this);
    this.wsw.setWantOpen(true);
    this.requestLock = new Lock;
    this.responseHandler = null;
    this.openCond = new Cond;
    this.pendingResponse = null;
    this.pendingResponseCond = new Cond;
    this.rpcThrottle = new Throttle('rpc');
  }
  onOpen(e) {
    this.isOpen = true;
    this.openCond.broadcast();
  }
  onMessage(e) {
    assert(this.requestLock.locked);
    this.pendingResponse = e;
    this.pendingResponseCond.broadcast();
  }
  onClose(e) {
    this.isOpen = false;
    this.pendingResponseCond.broadcast();
  }
  shouldAutoReopen() {
    return true;
  }
  async rawRequest(req) {
    let resp = null;
    while (1) {
      await this.requestLock.with(async () => {
        if (!this.isOpen) {
          console.log('RPC waiting for open');
          return;
        }

        this.wsw.ws.send(req);
        this.pendingResponse = null;
        while (this.isOpen && this.pendingResponse === null) {
          await this.pendingResponseCond;
        }
        if (!this.isOpen) {
          console.log('RPC waiting for re-open');
          return;
        }

        resp = this.pendingResponse.data;
        assert(resp !== null);
        if (typeof resp == 'string') {
          console.log(`RPC got error: '${resp}'`);
          await this.rpcThrottle;
          return;
        }
        this.rpcThrottle.reset();
        console.log(`RPC got good response: ${resp}`);
      });
      if (resp instanceof ArrayBuffer) {
        return resp.data;
      }
      if (!this.isOpen) {
        await this.openCond;
      }
    }
  }
  async reqRead(addr, len) {
    let dv = new DataView(new ArrayBuffer(17));
    dv.setInt8(0, 1); // RPC_REQ_READ
    dv.setBigUint64(1, addr, true);
    dv.setBigUint64(9, BigInt(len), true);
    return await this.rawRequest(dv);
  }
  async reqWrite(addr, data) {
    assert(ArrayBuffer.isView(data));
    let headerLen = 17;
    let ab = new ArrayBuffer(headerLen + data.byteLength);
    new Uint8Array(ab, headerLen).set(new Uint8Array(data));
    let dv = new DataView(ab);
    dv.setInt8(0, 2); // RPC_REQ_WRITE
    dv.setBigUint64(1, addr, true);
    dv.setBigUint64(9, BigInt(data.length), true);
    return await this.rawRequest(ab);
  }
}

class HoseConn {
  constructor(baseURL) {
    this.wsw = new WSWrapper(`${baseURL}/ws/hose`, this);
  }
  setWantOpen(wantOpen) {
    this.wsw.setWantOpen(wantOpen);
  }
  onOpen(e) {
  }
  onMessage(e) {
    console.log(`hose message ${e.data}`);
  }
  onClose(e) {
  }
}

async function go() {
  let baseURL = 'ws://127.0.0.1:8002';
  let rpcConn = new RPCConn(baseURL);
  let data = await rpcConn.reqRead(0x1238n, 40);
  console.log(data);
  rpcConn.wsw.setWantOpen(false);

  let hoseConn = new HoseConn(baseURL);
  hoseConn.setWantOpen(true);

}
go();
</script>
