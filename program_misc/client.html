<script>
function assert(x) {
  if (!(x)) {
    throw new Error('assertion failed');
  }
}
function sleep(n) {
  let { promise, resolve, reject } = Promise.withResolvers();
  setTimeout(resolve, n);
  return promise;
}

function doRead(addr, len) {
  return theRPCConn.reqRead(addr, len);
}
function doWrite(addr, data) {
  return theRPCConn.reqWrite(addr, data);
}

class BaseType {}
class IntBaseType extends BaseType {
  constructor(name, dataViewName, {needBigWrap} = {}) {
    super();
    this.name = name;
    let getLocal = new Function(
      'dv', 'off',
      `return dv.get${dataViewName}(off, true);`
    );
    let xval = needBigWrap ? 'BigInt(val)' : 'val';
    let setLocal = new Function(
      'dv', 'off', 'val',
      `return dv.set${dataViewName}(off, ${xval}, true);`
    );

    let size = parseInt(name.slice(1)) / 8;
    // TODO: this kinda sucks, would be better to have a way to aggregate what's needed.  probably we don't even want this at all.  too slow and not synchronized. 
    let getRemote = async (addr) => {
      let dv = await doRead(addr, size);
      return getLocal(dv, 0);
    };
    let setRemote = (addr, val) => {
      let dv = new DataView(size);
      setLocal(dv, 0, val);
      return doWrite(addr, dv);
    };

    this.getLocal = getLocal;
    this.getRemote = getRemote;
    this.setLocal = setLocal;
    this.setRemote = setRemote;

  }
}

let u8  = new IntBaseType('u8',  'Uint8');
let u16 = new IntBaseType('u16', 'Uint16');
let u32 = new IntBaseType('u32', 'Uint32');
let u64 = new IntBaseType('u64', 'BigUint64', {needBigWrap: true});
let s8  = new IntBaseType('s8',  'Int8');
let s16 = new IntBaseType('s16', 'Int16');
let s32 = new IntBaseType('s32', 'Int32');
let s64 = new IntBaseType('s64', 'BigInt64', {needBigWrap: true});
let f32 = new IntBaseType('f32', 'Float32');
let f64 = new IntBaseType('f64', 'Float64');


let utf8Decoder = new TextDecoder();
let CString = new BaseType;
CString.getLocal = (dv, off) => {
  let maxLen = Math.min(0x1000, dv.byteLength - off);
  let len = 0;
  while (len < maxLen && dv.getInt8(off + len) != 0) {
    len++;
  }
  let u8 = new Uint8Array(dv.buffer, dv.byteOffset + off, len);
  return utf8Decoder.decode(u8);
};

class Struct {
  constructor(name, sizeof, fields) {
    this.name = name;
    this.sizeof = sizeof;
    this.fields = fields;
    this.Local = this.makeLocalClass();
    this.Remote = this.makeRemoteClass();
  }
  makeLocalClass() {
    let argNames = [];
    let argVals = [];
    let code = `
      class ${this.name}_Local {
        constructor(dv) {
          this.dv = (dv instanceof DataView) ? dv : new DataView(dv);
        }
    `;
    for (let [fieldName, off, ty] of this.fields) {
      if (ty instanceof BaseType) {
        argNames.push(`getLocal_${fieldName}`, `setLocal_${fieldName}`);
        argVals.push(ty.getLocal, ty.setLocal);
        code += `
          get ${fieldName}() { return getLocal_${fieldName}(this.dv, ${off}); }
          set ${fieldName}(val) { return setLocal_${fieldName}(this.dv, ${off}, val); }
        `
      } else {
        assert(false);
      }
    }
    code += `
      }
      return ${this.name}_Local;
    `;
    return new Function(...argNames, code)(...argVals);
  }
  makeRemoteClass() {
    let argNames = [];
    let argVals = [];
    let code = `
      class ${this.name}_Remote {
        constructor(addr) {
          this.addr = addr;
        }
    `;
    for (let [fieldName, off, ty] of this.fields) {
      if (ty instanceof BaseType) {
        argNames.push(`getRemote_${fieldName}`, `setRemote_${fieldName}`);
        argVals.push(ty.getRemote, ty.setRemote);
        let setterName = 'set' + fieldName[0].toUpperCase() + fieldName.slice(1);
        code += `
          ${fieldName}() { return getRemote_${fieldName}(this.addr + ${off}); }
          ${setterName}(val) { return setRemote_${fieldName}(this.addr + ${off}, val); }
        `
      } else {
        assert(false);
      }
    }
    code += `
      }
      return ${this.name}_Remote;
    `;
    return new Function(...argNames, code)(...argVals);
  }
}

class Cond {
  constructor() {
    this.waiters = [];
  }
  broadcast() {
    for (let waiter of this.waiters) {
      waiter();
    }
  }
  wait() {
    let { promise, resolve, reject } = Promise.withResolvers();
    this.waiters.push(resolve);
    return promise;
  }
  then(f, r) {
    return this.wait().then(f, r);
  }
}

class Lock {
  constructor() {
    this.locked = false;
    this.waiters = [];
  };
  lock() {
    if (!this.locked) {
      this.locked = true;
      return Promise.resolve(undefined);
    } else {
      let { promise, resolve, reject } = Promise.withResolvers();
      this.waiters.push(resolve);
      return promise;
    }
  }
  unlock() {
    assert(this.locked);
    this.locked = false;
    let resolve = this.waiters.shift();
    if (resolve !== undefined) {
      resolve();
    }
  }
  async with(cb) {
    console.log('with entry');
    await this.lock();
    console.log('with got lock');
    let isUnlocked = false;
    let unlock = () => {
      if (!isUnlocked) {
        isUnlocked = true;
        this.unlock();
      }
    };
    try {
      return await cb(unlock);
    } finally {
      unlock();
    }
  }
}

class Throttle {
  constructor(name, defaultDelay = 100) {
    this.defaultDelay = defaultDelay;
    this.name = name;
    this.reset();
  }
  reset() {
    this.delay = this.defaultDelay;
  }
  then(f, r) {
    let delay = this.delay;
    this.delay *= 2;
    console.log(`Throttle "${this.name}" waiting for ${delay} ms`);
    return sleep(delay).then(f, r);
  }
}

class WSWrapper {
  constructor(url, delegate) {
    this.wsURL = url;
    this.delegate = delegate;
    this.openThrottle = new Throttle('open');
    this.state = 'idle';
    this.ws = null;
    this.wantOpen = false;
  }
  setWantOpen(wantOpen) {
    this.wantOpen = wantOpen;
    this.openCloseWSAsNeeded();
  }
  openCloseWSAsNeeded() {
    if (this.state == 'idle' && this.wantOpen) {
      this.openWS();
    } else if (this.state == 'open' && !this.wantOpen) {
      console.log(`closing ${this.wsURL}`);
      this.ws.close();
    }
  }
  openWS() {
    assert(this.ws === null);
    assert(this.state == 'idle');
    console.log(`connecting to ${this.wsURL}`);
    let ws = new WebSocket(this.wsURL);
    this.ws = ws;
    this.state = 'connecting';
    ws.binaryType = 'arraybuffer';
    ws.onopen = (e) => {
      assert(this.ws === ws);
      this.state = 'open';
      console.log(`opened connection to ${this.wsURL}`);
      this.delegate.onOpen(e);
      // if it doesn't close quickly, then reset throttle
      setTimeout(() => {
        if (this.ws === ws) {
          this.openThrottle.reset();
        }
      }, 1000);
    };
    ws.onmessage = (e) => {
      assert(this.ws === ws);
      this.delegate.onMessage(e);
    };
    ws.onclose = (e) => {
      assert(this.ws === ws);
      console.log(`closed connection to ${this.wsURL}`);
      this.ws = null;
      if (this.wantOpen) {
        this.state = 'openThrottle';
        (async () => {
          await this.openThrottle;
          this.state = 'idle';
          this.openCloseWSAsNeeded();
        })();
      } else {
        this.state = 'idle';
      }
      this.delegate.onClose(e);
    };
  }
}

class RPCConn {
  constructor(baseURL) {
    this.wsw = new WSWrapper(`${baseURL}/ws/rpc`, this);
    this.wsw.setWantOpen(true);
    this.responseHandler = null;
    this.updateCond = new Cond;
    this.pendingResponses = [];
    this.pendingResponseCond = new Cond;
    this.rpcThrottle = new Throttle('rpc');
    this.helloData = null;
  }
  onOpen(e) {
    this.isOpen = true;
    this.updateCond.broadcast();
    this.pendingResponseCallbacks = [(data) => {
      if (typeof data == 'string') {
        console.log(`early error! ${data}`);
        return;
      }
      assert(data instanceof ArrayBuffer);
      let dv = new DataView(data);
      this.helloData = {
        targetStart: dv.getBigUint64(0, true),
      };
      console.log('hello', this.helloData);
      this.updateCond.broadcast();
    }];
  }
  onMessage(e) {
    let cb = this.pendingResponseCallbacks.shift(1);
    if (!cb) {
      throw new Error('got unsolicited packet');
    }
    cb(e.data);
  }
  onClose(e) {
    this.isOpen = false;
    this.updateCond.broadcast();
  }
  async rawRequest(req) {
    let resp = null;
    outerLoop: while (1) {
      if (!this.isOpen) {
        console.log('RPC waiting for open');
        while (!this.isOpen) {
          await this.updateCond;
        }
      }

      this.wsw.ws.send(req);
      let haveResponse = false;
      let response = null;
      this.pendingResponseCallbacks.push((resp) => {
        response = resp;
        haveResponse = true;
        this.updateCond.broadcast();
      });

      while (!haveResponse) {
        if (!this.isOpen) {
          console.log('RPC waiting for re-open');
          continue outerLoop;
        }
        await this.updateCond;
      }

      if (typeof response == 'string') {
        console.log(`RPC got error: '${resp}'`);
        await this.rpcThrottle;
        continue outerLoop;
      }

      assert(response instanceof ArrayBuffer);
      this.rpcThrottle.reset();
      console.log(`RPC got good response: ${response}`);

      return new DataView(response);
    }
  }
  async reqRead(addr, len) {
    let dv = new DataView(new ArrayBuffer(17));
    dv.setInt8(0, 1); // RPC_REQ_READ
    dv.setBigUint64(1, BigInt(addr), true);
    dv.setBigUint64(9, BigInt(len), true);
    return await this.rawRequest(dv);

  }
  async reqWrite(addr, data) {
    assert(ArrayBuffer.isView(data));
    let headerLen = 17;
    let ab = new ArrayBuffer(headerLen + data.byteLength);
    new Uint8Array(ab, headerLen).set(new Uint8Array(data));
    let dv = new DataView(ab);
    dv.setInt8(0, 2); // RPC_REQ_WRITE
    dv.setBigUint64(1, addr, true);
    dv.setBigUint64(9, BigInt(data.length), true);
    return await this.rawRequest(ab);
  }
}

class HoseConn {
  constructor(baseURL) {
    this.wsw = new WSWrapper(`${baseURL}/ws/hose`, this);
  }
  setWantOpen(wantOpen) {
    this.wsw.setWantOpen(wantOpen);
  }
  onOpen(e) {
  }
  onMessage(e) {
    console.log(`hose message ${e.data}`);
  }
  onClose(e) {
  }
}

/*
async function go() {
  let baseURL = 'ws://127.0.0.1:8002';
  let rpcConn = new RPCConn(baseURL);
  let data = await rpcConn.reqRead(0x1238n, 40);
  console.log(data);
  rpcConn.wsw.setWantOpen(false);

  let hoseConn = new HoseConn(baseURL);
  hoseConn.setWantOpen(true);

}
go();
*/

async function test() {
  theRPCConn = new RPCConn('ws://127.0.0.1:8002');
  let rpc_req = new Struct('rpc_req', 17, [
    ['type', 0, u8],
    ['rw_addr', 1, u64],
    ['dummy', 1, CString],
    ['rw_len', 9, u64],
  ]);
  let rl = new rpc_req.Local(new ArrayBuffer(17));
  rl.rw_addr = 0x41414141;
  console.log(rl.rw_addr);
  console.log(rl.dummy);
  let rr = new rpc_req.Remote(0x1000);
  console.log(await rr.rw_len());
}
test();
</script>
