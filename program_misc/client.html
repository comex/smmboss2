<script>
function assert(x) {
  if (!(x)) {
    throw new Error('assertion failed');
  }
}
function sleep(n) {
  let { promise, resolve, reject } = Promise.withResolvers();
  setTimeout(resolve, n);
  return promise;
}

class BaseType {
  constructor(name, dataViewName, {needBigWrap} = {}) {
    this.name = name;
    let getLocal = new Function('dv', 'off', `return dv.get${dataViewName}(off, true);`);
    let xval = needBigWrap ? 'BigInt(val)' : 'val';
    let setLocal = new Function('dv', 'off', 'val', `return dv.set${dataViewName}(off, {xval}, true);`);

    let size = parseInt(name.slice(1)) / 8;
    let getRemote = async (addr) => {
      let dv = await doRead(addr, size);
      return getLocal(dv, 0);
    };
    let setRemote = (addr, val) => {
      let dv = new DataView(size);
      setLocal(dv, 0, val);
      return doWrite(addr, dv);
    };

    this.getLocal = getLocal;
    this.getRemote = getRemote;
    this.setLocal = setLocal;
    this.setRemote = setRemote;

    this.getLocalBinder = function(offset) {
      return getLocal(this.dv, offset);
    }
    this.setLocalBinder = function(offset, val) {
      return setLocal(this.dv, offset, val);
    }
    this.getRemoteBinder = function(offset) {
      return getRemote(this.addr + offset);
    }
    this.setRemoteBinder = function(offset, val) {
      return setRemote(this.addr + offset, val);
    }
  }
}

let u8  = new BaseType('u8',  'Uint8');
let u16 = new BaseType('u16', 'Uint16');
let u32 = new BaseType('u32', 'Uint32');
let u64 = new BaseType('u64', 'BigUint64', {needBigWrap: true});
let s8  = new BaseType('s8',  'Int8');
let s16 = new BaseType('s16', 'Int16');
let s32 = new BaseType('s32', 'Int32');
let s64 = new BaseType('s64', 'BigInt64', {needBigWrap: true});
let f32 = new BaseType('f32', 'Float32');
let f64 = new BaseType('f64', 'Float64');

class Struct {
  constructor(name, sizeof, fields) {
    this.name = name;
    this.sizeof = sizeof;
    this.fields = fields;
    this.Local = this.makeLocalClass();
    this.Remote = this.makeRemoteClass();
  }
  makeLocalClass() {
    
    let argNames = [];
    let argVals = [];
    let code = `
      class ${name}_Local {
        constructor(dv) {
          this.dv = (dv instanceof DataView) ? dv : new DataView(dv);
        }
    `;
    for (let [fieldName, off, ty] of this.fields) {
      assert(typeof off == 'number');
      if (typeof ty == 'string') {
        let mapped = this.baseTypeMap[ty];
        if (!mapped) {
          throw new Error(`invalid base type ${ty}`);
        }
        let xval = 'val';
        if (ty == 'u64' || ty == 'u32') {
          // setBig[U]int64 requires it to actually be big
          xval = 'BigInt(val)';
        }
        code += `
          get ${fieldName}() { return this.dv.get${mapped}(${off}, true); }
          set ${fieldName}(val) { this.dv.set${mapped}(${xval}, true); }
        `;
      } else {
        assert(ty instanceof Struct);
        argNames.push(`_typeof_${fieldName}`);
        argVals.push(ty);
        code += `
          get ${fieldName}() {
            let ret = this._cached_${fieldName};
            if (typeof ret === 'undefined') {
              ret = this._cached_${fieldName} = new _typeof_${fieldName}(new DataView(this.dv, ${off}));
            }
            return ret;
          }
        `;

      }

    }

    code += `
      }
      ${name}_Local.isLocalClass = true;
      return ${name}_Local;
    `;
    return new Function(...argNames, code)(...argVals);
  }
  makeRemoteClass() {
    let argNames = [];
    let argVals = [];
    let code = `
      class ${name}_Remote {
        constructor(addr) {
          this.addr = addr;
        }
    `;
    for (let [fieldName, off, ty] of this.fields) {
      assert(typeof off == 'number');
      if (typeof ty == 'string') {
        let mapped = this.baseTypeMap[ty];
        if (!mapped) {
          throw new Error(`invalid base type ${ty}`);
        }
        let fieldSize = parseInt(ty.slice(1)) / 8;
        let xval = 'val';
        if (ty == 'u64' || ty == 'u32') {
          // setBig[U]int64 requires it to actually be big
          xval = 'BigInt(val)';
        }
        let setterName = 'set' + fieldName[0].toUpperCase() + fieldName.slice(1);
        argNames.push(`getRemote_${fieldName}`);
        argNames.push(`setRemote_${fieldName}`);
        argVals.push(
        code += `
          ${fieldName}() { return getRemote_${fieldName}(this.addr, off); }
          ${setterName}(val) { return setRemote_${fieldName}(this.addr, off, val); }
        `;
      } else {
        assert(ty instanceof Struct);
        argNames.push(`_typeof_${fieldName}`);
        argVals.push(ty);
        code += `
          get ${fieldName}() {
            let ret = this._cached_${fieldName};
            if (typeof ret === 'undefined') {
              ret = this._cached_${fieldName} = new _typeof_${fieldName}(new DataView(this.dv, ${off}));
            }
            return ret;
          }
        `;

      }

    }

    code += `
      }
      ${name}_Remote.isRemoteClass = true;
      return ${name}_Remote;
    `;
    return new Function(...argNames, code)(...argVals);
  }
}
*/

class Cond {
  constructor() {
    this.waiters = [];
  }
  broadcast() {
    for (let waiter of this.waiters) {
      waiter();
    }
  }
  wait() {
    let { promise, resolve, reject } = Promise.withResolvers();
    this.waiters.push(resolve);
    return promise;
  }
  then(f, r) {
    return this.wait().then(f, r);
  }
}

class Lock {
  constructor() {
    this.locked = false;
    this.waiters = [];
  };
  lock() {
    if (!this.locked) {
      this.locked = true;
      return Promise.resolve(undefined);
    } else {
      let { promise, resolve, reject } = Promise.withResolvers();
      this.waiters.push(resolve);
      return promise;
    }
  }
  unlock() {
    assert(this.locked);
    this.locked = false;
    let resolve = this.waiters.shift();
    if (resolve !== undefined) {
      resolve();
    }
  }
  async with(cb) {
    console.log('with entry');
    await this.lock();
    console.log('with got lock');
    let isUnlocked = false;
    let unlock = () => {
      if (!isUnlocked) {
        isUnlocked = true;
        this.unlock();
      }
    };
    try {
      return await cb(unlock);
    } finally {
      unlock();
    }
  }
}

class Throttle {
  constructor(name, defaultDelay = 100) {
    this.defaultDelay = defaultDelay;
    this.name = name;
    this.reset();
  }
  reset() {
    this.delay = this.defaultDelay;
  }
  then(f, r) {
    let delay = this.delay;
    this.delay *= 2;
    console.log(`Throttle "${this.name}" waiting for ${delay} ms`);
    return sleep(delay).then(f, r);
  }
}

class WSWrapper {
  constructor(url, delegate) {
    this.wsURL = url;
    this.delegate = delegate;
    this.openThrottle = new Throttle('open');
    this.state = 'idle';
    this.ws = null;
    this.wantOpen = false;
  }
  setWantOpen(wantOpen) {
    this.wantOpen = wantOpen;
    this.openCloseWSAsNeeded();
  }
  openCloseWSAsNeeded() {
    if (this.state == 'idle' && this.wantOpen) {
      this.openWS();
    } else if (this.state == 'open' && !this.wantOpen) {
      console.log(`closing ${this.wsURL}`);
      this.ws.close();
    }
  }
  openWS() {
    assert(this.ws === null);
    assert(this.state == 'idle');
    console.log(`connecting to ${this.wsURL}`);
    let ws = new WebSocket(this.wsURL);
    this.ws = ws;
    this.state = 'connecting';
    ws.binaryType = 'arraybuffer';
    ws.onopen = (e) => {
      assert(this.ws === ws);
      this.state = 'open';
      console.log(`opened connection to ${this.wsURL}`);
      this.delegate.onOpen(e);
      // if it doesn't close quickly, then reset throttle
      setTimeout(() => {
        if (this.ws === ws) {
          this.openThrottle.reset();
        }
      }, 1000);
    };
    ws.onmessage = (e) => {
      assert(this.ws === ws);
      this.delegate.onMessage(e);
    };
    ws.onclose = (e) => {
      assert(this.ws === ws);
      console.log(`closed connection to ${this.wsURL}`);
      this.ws = null;
      if (this.wantOpen) {
        this.state = 'openThrottle';
        (async () => {
          await this.openThrottle;
          this.state = 'idle';
          this.openCloseWSAsNeeded();
        })();
      } else {
        this.state = 'idle';
      }
      this.delegate.onClose(e);
    };
  }
}

class RPCConn {
  constructor(baseURL) {
    this.wsw = new WSWrapper(`${baseURL}/ws/rpc`, this);
    this.wsw.setWantOpen(true);
    this.requestLock = new Lock;
    this.responseHandler = null;
    this.openCond = new Cond;
    this.pendingResponse = null;
    this.pendingResponseCond = new Cond;
    this.rpcThrottle = new Throttle('rpc');
  }
  onOpen(e) {
    this.isOpen = true;
    this.openCond.broadcast();
  }
  onMessage(e) {
    assert(this.requestLock.locked);
    this.pendingResponse = e;
    this.pendingResponseCond.broadcast();
  }
  onClose(e) {
    this.isOpen = false;
    this.pendingResponseCond.broadcast();
  }
  shouldAutoReopen() {
    return true;
  }
  async rawRequest(req) {
    let resp = null;
    while (1) {
      await this.requestLock.with(async () => {
        if (!this.isOpen) {
          console.log('RPC waiting for open');
          return;
        }

        this.wsw.ws.send(req);
        this.pendingResponse = null;
        while (this.isOpen && this.pendingResponse === null) {
          await this.pendingResponseCond;
        }
        if (!this.isOpen) {
          console.log('RPC waiting for re-open');
          return;
        }

        resp = this.pendingResponse.data;
        assert(resp !== null);
        if (typeof resp == 'string') {
          console.log(`RPC got error: '${resp}'`);
          await this.rpcThrottle;
          return;
        }
        this.rpcThrottle.reset();
        console.log(`RPC got good response: ${resp}`);
      });
      if (resp instanceof ArrayBuffer) {
        return resp.data;
      }
      if (!this.isOpen) {
        await this.openCond;
      }
    }
  }
  async reqRead(addr, len) {
    let dv = new DataView(new ArrayBuffer(17));
    dv.setInt8(0, 1); // RPC_REQ_READ
    dv.setBigUint64(1, addr, true);
    dv.setBigUint64(9, BigInt(len), true);
    return await this.rawRequest(dv);
  }
  async reqWrite(addr, data) {
    assert(ArrayBuffer.isView(data));
    let headerLen = 17;
    let ab = new ArrayBuffer(headerLen + data.byteLength);
    new Uint8Array(ab, headerLen).set(new Uint8Array(data));
    let dv = new DataView(ab);
    dv.setInt8(0, 2); // RPC_REQ_WRITE
    dv.setBigUint64(1, addr, true);
    dv.setBigUint64(9, BigInt(data.length), true);
    return await this.rawRequest(ab);
  }
}

class HoseConn {
  constructor(baseURL) {
    this.wsw = new WSWrapper(`${baseURL}/ws/hose`, this);
  }
  setWantOpen(wantOpen) {
    this.wsw.setWantOpen(wantOpen);
  }
  onOpen(e) {
  }
  onMessage(e) {
    console.log(`hose message ${e.data}`);
  }
  onClose(e) {
  }
}

/*
async function go() {
  let baseURL = 'ws://127.0.0.1:8002';
  let rpcConn = new RPCConn(baseURL);
  let data = await rpcConn.reqRead(0x1238n, 40);
  console.log(data);
  rpcConn.wsw.setWantOpen(false);

  let hoseConn = new HoseConn(baseURL);
  hoseConn.setWantOpen(true);

}
go();
*/

/*
function test() {
  let rpc_req = new Struct('rpc_req', 17, [
    ['type', 0, 'u8'],
    ['rw_addr', 1, 'u64'],
    ['rw_len', 9, 'u64'],
  ]);
}
test();
*/
console.log(f64.get(new DataView(new Uint32Array([0xdeadbeef, 0xdeadbeef]).buffer), 0));
</script>
