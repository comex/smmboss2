import smmboss, inspect
from operator import itemgetter
def get_info_for_build(build_id, classes_to_export):
    mm = smmboss.MM.detached(build_id=build_id)
    world = mm.world
    cls_infos = {}
    def add_info_for(cls):
        if cls.__name__ in cls_infos:
            return
        cls_infos[cls.__name__] = None
        if issubclass(cls, world.GuestStruct):
            base = cls._base_guest_struct()
            cls_info = {
                'kind': 'struct',
                'base': base and base.__name__,
                'props': {},
            }
            for prop_name, prop in cls._properties():
                assert isinstance(prop, world.MyProperty)
                add_info_for(prop.ptr_cls)
                prop_info = {
                    'offset': prop.offset,
                    'ptr_cls': prop.ptr_cls.__name__,
                }
                cls_info['props'][prop_name] = prop_info
        elif issubclass(cls, world.GuestPtrPtrBase):
            add_info_for(cls.val_ty)
            cls_info = {
                'kind': 'ptr',
                'val_cls': cls.val_ty.__name__,
            }
        elif issubclass(cls, world.GuestFixedArrayBase):
            cls_info = {
                'kind': 'fixed_array',
                'count': cls.count,
                'val_ptr_cls': cls.val_ptr_ty,
            }
        elif ((issubclass(cls, world.GuestPrimPtr) and hasattr(cls, 'code')) or
              cls is world.GuestPtr or
              cls is world.GuestCString):
            cls_info = {'kind': 'primitive'}
        else:
            raise Exception(f"? {cls}")
        cls_infos[cls.__name__] = cls_info
    for cls_name in classes_to_export:
        cls = getattr(world, cls_name)
        add_info_for(cls)
    return {
        'classes': cls_infos,
    }

#        line = f'class {cls_name} : public ManualAdditions<{cls_name}>'
#        if base is not None:
#            line += f', public {base.__name__}'
#        line += ' {'
#        print(line)
#
#        for field_name in field_names:
#            print('FIELD(
#            offset = prop.offset
#        print('};')

def map_values(f, some_dict):
    return {key: f(value) for (key, value) in some_dict.items()}

def all_keys(iterable_of_iterables):
    return list({key: None
                 for outer in iterable_of_iterables
                 if outer is not None
                 for key in outer})

# converts
# {'a': {'x': 1, 'y': 2}, 'b': {'x': 3, 'x': 4}}
# ->
# {'x': {'a': 1, 'b': 3}, 'y': {'a': 2, 'b': 4}}
_no_default = object()
def rotate(items_iter_or_dict, default=_no_default):
    if isinstance(items_iter_or_dict, dict):
        items_iter = items_iter_or_dict.items()
    else:
        items_iter = iter(items_iter_or_dict)
    items = list(items_iter)
    return {
        inner_key: {
            outer_key: (inner[inner_key] if default is _no_default else
                        default if inner is None else
                        inner.get(inner_key, default))
            for (outer_key, inner) in items
        }
        for inner_key in all_keys(inner for (outer_key, inner) in items)
    }

def assert_all_values_same(dict_, ignore_nones=True):
    have_the_value = False
    have_none = False
    for key, val in dict_.items():
        if val is None and ignore_nones:
            have_none = True
            continue
        if not have_the_value:
            the_key = key
            the_value = val
            have_the_value = True
        else:
            if the_value != val:
                raise ValueError(f"different value in dict: {the_key!r} -> {the_value!r} but {key!r} -> {val!r} in: {dict!r}")
    if not have_the_value:
        if have_none:
            return None
        raise ValueError(f"assert_all_values_same: empty dict")
    return the_value

def export_class(classes_by_bid, cls_name):
    cls_info_by_bid_r = rotate(classes_by_bid[cls_name], default=None)
    base = assert_all_values_same(cls_info_by_bid_r['base'])
    props_by_bid = cls_info_by_bid_r['props']
    for prop_name, info_by_bid in rotate(props_by_bid, default=None).items():
        info_by_bid_r = rotate(info_by_bid, default=None)
        ptr_cls = assert_all_values_same(info_by_bid_r['ptr_cls'])
        print(prop_name, ptr_cls)

def print_autogen_header():
    import subprocess
    version = subprocess.check_output(['git', 'describe', '--always', '--dirty'], text=True).strip()
    print(f'''
//
// start autogenerated by smmboss2 ({version}) src/export.py
///
''')
def print_autogen_footer():
    print(f'''
//
// end autogenerated
///
''')

def go(classes_to_export):
    print_autogen_header()
    build_info = {
        build_id: get_info_for_build(build_id, classes_to_export)
        for build_id in [
            'edb8feede2bfa3ffd1adf65a4424361a00000000000000000000000000000000',
            'aac32b77fb8e040b18e5940f37ca6c7f00000000000000000000000000000000',
        ]
    }
    classes_by_bid = rotate(rotate(build_info)['classes'])
    for cls_name in classes_to_export:
        export_class(classes_by_bid, cls_name)
    print_autogen_footer()

go(
    classes_to_export = [
        'AreaSystem',
        'Hitbox',
    ]
)
