<meta charset="UTF-8">
<style>
@font-face {
  font-family: fa-solid-900;
  src: url('fa-solid-900.woff2') format('woff2');
}
#controls-left > label {
  display: block;
  transition: background-color 0.5s ease-out;
  background-color: #fff;
}
#controls-left > label:hover {
  transition: background-color 0.0s linear;
  background-color: #f3f3f3;
}
#controls-left[inert] {
  opacity: 0.25;
}
#controls-right {
  margin-left: auto;
  padding: 5px;
}
#stats > div {
  margin: 10px 0;
}
.box {
  border: 1px solid grey;
}
#scrubber-shuttle > button {
  font-family: fa-solid-900;
  height: 22px;
}
#controls-left > label {
  padding: 3px;
  display: flex;
  align-items: center;
  user-select: none;
}
#controls-left > label > input[type=checkbox] {
  display: block;
  vertical-align: middle;
  margin: 0;
  margin-right: 3px;
}
#controls-left > label > span {
  display: block;
  vertical-align: middle;
}
</style>

<div id="overrun"></div>
<div id="columns" style="display: flex; flex-direction: row; gap: 10px ">
  <div id="col1" style="display: flex; flex-direction: column">
    <svg width="500" height="500" id="diagram" class="box"></svg>
    <div class="box" style="align-content: end; padding: 3px; border-top: none">
      <div id="scrubber-row" style="display: flex; flex-direction: row; align-content: stretch">
        <input type="range" id="scrubber" min="-1" max="0" value="1" step="1" disabled style="flex: 1">
        <div id="scrubber-display">0/0</div>
      </div>
      <div id="scrubber-shuttle" style="display: flex; flex-direction: row; gap: 4px; justify-content: end">
        <button id="start-button">&#xF049;</button>
        <button id="back1-button">&#xF04A;</button>
        <button id="play-button">&#xF04B;</button>
        <button id="fwd1-button">&#xF04E;</button>
        <button id="end-button">&#xF050;</button>
        <button id="save-button">Save</button>
        <button id="load-button">Load</button>
        <button id="live-button">Live</button>
        <button id="disconnect-button">Disconnect</button>
      </div>
    </div>
  </div>
  <div id="col2" style="display: flex; flex-direction: column; flex: 1">
    <div id="stats" style="border: 1px solid grey; font-family: monospace; height: 300px; overflow: scroll;"></div>
    <div id="spacer" style="margin-top: auto"></div>

    <div id="controls" style="border: 1px solid grey; align-content: stretch; display: flex; flex-direction: row">
      <div id="controls-left">
        <label for="controls-backpressure"><input type="checkbox" id="controls-backpressure"><span>Backpressure</span></label>
        <label for="controls-bg-events"><input type="checkbox" id="controls-bg-events"><span>Background Collision Events</span></label>
      </div>
      <div id="controls-right">
        <div id="js-mem-container">
          JS Mem: <span id="js-mem">?</span> MB
        </div>
      </div>
    </div>
  </div>
</div>

<script>
function hex(n) {
  return '0x'+n.toString(16);
}
function assert(x) {
  if (!(x)) {
    throw new Error('assertion failed');
  }
}
function yieldMe() {
  let { promise, resolve, reject } = Promise.withResolvers();
  queueMicrotask(resolve);
  return promise;
}
function sleep(n) {
  let { promise, resolve, reject } = Promise.withResolvers();
  setTimeout(resolve, n);
  return promise;
}

async function doRead(addr, len) {
  let resp = await theRPCConn.reqRead(addr, len);
  if (resp.byteLength < len) {
    throw new Error(`short read addr=${addr} len=${len} actual=${resp.byteLength}`);
  }
  return resp;
}
async function doWrite(addr, data) {
  let [actual, len] = await theRPCConn.reqWrite(addr, data);
  if (actual < len) {
    throw new Error(`short write addr=${addr} len=${len} actual=${actual}`);
  }
}

class Primitive {}
class IntType extends Primitive {
  constructor(name, sizeof, dataViewName, {needBigWrap} = {}) {
    super();
    this.name = name;
    this.sizeof = sizeof;
    let getLocal = new Function(
      'dv', 'off',
      `return dv.get${dataViewName}(off, true);`
    );
    let xval = needBigWrap ? 'BigInt(val)' : 'val';
    let setLocal = new Function(
      'dv', 'off', 'val',
      `return dv.set${dataViewName}(off, ${xval}, true);`
    );

    let size = parseInt(name.slice(1)) / 8;
    // TODO: this kinda sucks, would be better to have a way to aggregate what's needed.  probably we don't even want this at all.  too slow and not synchronized. 
    let getRemote = async (addr) => {
      let dv = await doRead(addr, size);
      return getLocal(dv, 0);
    };
    let setRemote = (addr, val) => {
      let dv = new DataView(new ArrayBuffer(size));
      setLocal(dv, 0, val);
      return doWrite(addr, dv);
    };

    this.getLocal = getLocal;
    this.getRemote = getRemote;
    this.setLocal = setLocal;
    this.setRemote = setRemote;

  }
}


let utf8Decoder = new TextDecoder();
class CStringType extends Primitive {
  // ??
}

class Tag8Type extends Primitive {
  sizeof = 8;
  getLocal(dv, off) {
    let bytes = [];
    for (let i = 0; i < 8; i++) {
      bytes.push(dv.getUint8(off + i));
    }
    while (bytes.length > 0 && bytes[bytes.length - 1] == 0) {
      bytes.pop();
    }
    return String.fromCharCode(...bytes);
  }
}

class CompoundType {
}

class CompoundTypeLocal {
  constructor(dv, off) {
    this.dv = (dv instanceof DataView) ? dv : new DataView(dv);
    this.off = off;
  }
  readPtrFromWithin(ptr, ty) {
    // this assumes someone wrote the _ptr field on this.
    assert(this._ptr !== undefined);
    let offset = ptr - this._ptr;
    assert(offset >= 0n && offset < 0x100000n);
    return ty.getLocal(this.dv, this.off + Number(offset));
  }
}

class FixedArrayLocal extends CompoundTypeLocal {
  constructor(dv, off) {
    super(dv, off);
  }
}

class FixedArray extends CompoundType {
  constructor(elmTy, count) {
    super();
    let elmTySizeof = elmTy.sizeof;
    if (elmTySizeof !== null) {
      assert(typeof elmTySizeof == 'number');
      this.sizeof = elmTySizeof * count;
    }
    if (elmTy instanceof CompoundType) {
      class Local extends FixedArrayLocal {
        constructor(dv, off) {
          super(dv, off);
          this._cache = [];
        }
        get(i) {
          assert(i >= 0 && i < count);
          let ret = this._cache[i];
          if (ret === undefined) {
            ret = this._cache[i] = new elmTy.Local(this.dv, this.off + i * elmTySizeof);
          }
          return ret;
        }
        map(f) {
          return Array.from(Array(this.count), (_, i) => f(this.get(i), i));
        }
        serialize() {
          return this.map((x) => x.serialize());
        }
      }
      Local.prototype.count = count;
      this.Local = Local;
    } else {
      let getLocal = elmTy.getLocal;
      class Local extends FixedArrayLocal {
        constructor(dv, off) {
          super(dv, off);
        }
        get(i) {
          assert(i >= 0 && i < count);
          return getLocal(this.dv, this.off + i * elmTySizeof);
        }
        // could implement set
        map(f) {
          return Array.from(Array(this.count), (_, i) => f(this.get(i), i));
        }
        serialize() {
          return this.map((x) => x);
        }
      }
      Local.prototype.count = count;
      this.Local = Local;
    }
  }
}

class StructLocal extends CompoundTypeLocal {
  constructor(dv, off) {
    super(dv, off);
    let sizeof = this.struct.sizeof;
    if (sizeof !== null) {
      assert(this.dv.byteLength >= off + this.struct.sizeof);
    }
  }
  serialize() {
    let ret = {};
    for (let {fieldName} of this.struct.fields) {
      let val = this[fieldName];
      if (val.serialize !== undefined) {
        val = val.serialize();
      }
      ret[fieldName] = val;
    }
    return ret;
  }

}

class Struct extends CompoundType {
  constructor(name, info, extraLocalMethods, mmTypes) {
    super();
    this.name = name;
    this.sizeof = info.sizeof ?? null;
    this.info = info;
    this.extraLocalMethods = extraLocalMethods;
    this.saneName = this.name.replaceAll(/[\(\),]/g, '_');
    this.mmTypes = mmTypes;
  }

  // lazy to avoid issues with recursion
  get fields() {
    if (this._fields !== undefined) {
      return this._fields;
    }
    this._fields = [];
    for (let [fieldName, {offset, ptr_cls}] of Object.entries(this.info.props)) {
      this._fields.push({fieldName, off: offset, ty: this.mmTypes.loadType(ptr_cls)});
    }
    return this._fields;
  }

  get Local() {
    if (this._Local !== undefined) {
      return this._Local;
    }
    let superclass = this.info.base ? this.mmTypes.loadType(this.info.base).Local : StructLocal;
    let argNames = ['superclass'];
    let argVals = [superclass];
    let code = `
      class ${this.saneName}_Local extends superclass {
        constructor(dv, off = 0) {
          super(dv, off);
    `
    for (let {fieldName, off, ty} of this.fields) {
      if (ty instanceof CompoundType) {
        code += `
          this._${fieldName} = undefined;
        `;
      }
    }
    code += `
        }
    `;
    for (let {fieldName, off, ty} of this.fields) {
      if (ty instanceof Primitive) {
        argNames.push(`getLocal_${fieldName}`, `setLocal_${fieldName}`);
        argVals.push(ty.getLocal, ty.setLocal);
        code += `
          get ${fieldName}() { return getLocal_${fieldName}(this.dv, this.off + ${off}); }
          set ${fieldName}(val) { return setLocal_${fieldName}(this.dv, this.off + ${off}, val); }
        `
      } else {
        assert(ty instanceof CompoundType);
        argNames.push(`ty_${fieldName}_Local`);
        argVals.push(ty.Local);
        // todo: cache
        code += `
          get ${fieldName}() {
            if (this._${fieldName} === undefined) {
              this._${fieldName} = new ty_${fieldName}_Local(this.dv, this.off + ${off});
            }
            return this._${fieldName};
          }
        `
      }
    }
    code += `
      }
      return ${this.saneName}_Local;
    `;
    let cls = new Function(...argNames, code)(...argVals);
    cls.prototype.struct = this;
    for (let {fieldName, off, ty} of this.fields) {
      cls.prototype[`offsetof_${fieldName}`] = off;
    }
    if (this.extraLocalMethods) {
      // inject a subclass
      cls = this.extraLocalMethods(cls);
    }
    this._Local = cls;
    return cls;
  }
  /*
  makeRemoteClass() {
    // TODO: redo this to be more useful
    let argNames = [];
    let argVals = [];
    let code = `
      class ${this.name}_Remote {
        constructor(addr) {
          this.addr = addr;
        }
    `;
    for (let [fieldName, off, ty] of this.fields) {
      if (ty instanceof Primitive) {
        argNames.push(`getRemote_${fieldName}`, `setRemote_${fieldName}`);
        argVals.push(ty.getRemote, ty.setRemote);
        let setterName = 'set' + fieldName[0].toUpperCase() + fieldName.slice(1);
        code += `
          ${fieldName}() { return getRemote_${fieldName}(this.addr + ${off}n); }
          ${setterName}(val) { return setRemote_${fieldName}(this.addr + ${off}n, val); }
        `
      } else {
        assert(ty instanceof CompoundType);
        argNames.push(`ty_${fieldName}`);
        argVals.push(ty);
        code += `
          ${fieldName}() { return new ty_${fieldName}(this.addr + ${off}n); }
        `
      }
    }
    code += `
      }
      return ${this.name}_Remote;
    `;
    return new Function(...argNames, code)(...argVals);
  }
  */

  getLocal(dv, off) {
    return new this.Local(dv, off);
  }
}

let ty = {
  u8:  new IntType('u8',  1, 'Uint8'),
  u16: new IntType('u16', 2, 'Uint16'),
  u32: new IntType('u32', 4, 'Uint32'),
  u64: new IntType('u64', 8, 'BigUint64', {needBigWrap: true}),
  s8 : new IntType('s8',  1, 'Int8'),
  s16: new IntType('s16', 2, 'Int16'),
  s32: new IntType('s32', 4, 'Int32'),
  s64: new IntType('s64', 8, 'BigInt64', {needBigWrap: true}),
  f32: new IntType('f32', 4, 'Float32'),
  f64: new IntType('f64', 8, 'Float64'),
  tag8: new Tag8Type,
  CString: new CStringType,
};
ty.GuestCString = ty.CString;
ty.GuestPtr = ty.u64;

class MMTypes {
  static extraLocalMethodsFor = {};

  constructor(helloInfo, exportJson) {
    Object.assign(this, ty);

    let buildId = toHex(helloInfo[1].buildId) + '00000000000000000000000000000000';
    assert(buildId in exportJson);
    this.export = exportJson[buildId];
    this.classes = this.export.classes;
    for (let name in this.classes) {
      this.loadType(name);
    }
  }

  loadType(name) {
    if (this[name] !== undefined) {
      return this[name];
    }
    let info = this.classes[name];
    if (info === undefined) {
      throw new Error(`struct ${name} not defined in json`);
    }
    let ty;
    switch (info.kind) {
    case 'primitive':
      // should be predefined
      throw new Error(`unknown primitive '${name}'`);
    case 'fixed_array':
      ty = new FixedArray(this.loadType(info.val_ptr_cls), info.count);
      break;
    case 'struct':
      ty = new Struct(name, info, this.constructor.extraLocalMethodsFor[name], this);
      break;
    case 'ptr':
      ty = this.GuestPtr; // todo: typing
      break;
    default:
      throw new Error(`unknown kind '${info.kind}'`);
    }
    this[name] = ty;
    return ty;
  }

}
MMTypes.extraLocalMethodsFor.Rect = (base) => class extends base {
  width() {
    return this.max.x - this.min.x;
  }
  height() {
    return this.max.y - this.min.y;
  }
};

class Reader {
  constructor(dv, off = 0) {
    if (dv instanceof ArrayBuffer) {
      dv = new DataView(dv);
    }
    if (dv instanceof Uint8Array) {
      dv = new DataView(dv.buffer, dv.byteOffset, dv.byteLength);
    }
    assert(dv instanceof DataView);
    this.dv = dv;
    this.off = off;
    this.size = this.dv.byteLength;
  }
  readOff(size) {
    let off = this.off;
    if (size > this.size - off) {
      throw new Error(`Reader overread - wanted ${size} only had ${this.size - off}/${this.size}`);
    }
    this.off = off + size;
    return off;
  }
  read(ty, size = null) {
    if (size === null) {
      size = ty.sizeof;
    }
    assert(typeof size == 'number');
    let off = this.readOff(size);
    return ty.getLocal(this.dv, off);
  }
  readArrayUnbounded(callback) {
    let out = [];
    while (this.off < this.size) {
      out.push(callback());
    }
    return out;
  }
  readArray(count, callback) {
    let out = [];
    for (let i = 0; i < count; i++) {
      out.push(callback());
    }
    return out;
  }
  expectEnd() {
    if (this.size != this.off) {
      throw new Error(`Reader underread by ${this.size - this.off}`);
    }
  }
  static with(dv, off, callback) {
    let self = new Reader(dv, off);
    let ret = callback(self);
    self.expectEnd();
    return ret;
  }
  remaining() {
    return this.size - this.off;
  }
}

// These could be structs but using Reader avoids a circular dependency
function readExlUtilRange(r) {
  return {start: r.read(ty.u64), size: r.read(ty.u64)}
}
function readHelloModInfo(r) {
  let ret = r.readArrayUnbounded(() => ({
    total: readExlUtilRange(r),
    text: readExlUtilRange(r),
    rodata: readExlUtilRange(r),
    data: readExlUtilRange(r),
    buildId: r.readArray(16, () => r.read(ty.u8)),
  }));
  ret.rawData = r.dv.buffer;
  return ret;
}

function toHex(array) {
  return array.map(num => num.toString(16).padStart(2, '0')).join('');
}

class SignalLink {
  static create(source, target, update) {
    if (target !== null && target.hasException) {
      return null;
    }
    if (source.hasException) {
      update(true, source.valueOrException, null);
      return null;
    }
    let link = new SignalLink;
    link.source = source;
    link.target = target;
    link.update = update;
    if (target !== null) {
      target.linksIn.add(link);
    }
    source.linksOut.add(link);
    if (source.hasValue) {
      update(false, source.valueOrException, link);
    }
    return link;
  }
  kill() {
    this.source.linksOut.delete(this);
    if (this.target !== null) {
      this.target.linksIn.delete(this);
    }
  }
}

class Signal {
  constructor(initialValue = undefined, hasInitialValue = true) {
    this.linksIn = new Set;
    this.linksOut = new Set;
    this.hasValue = hasInitialValue;
    this.hasException = false;
    this.valueOrException = initialValue;
  }
  static of(valueOrSig) {
    if (valueOrSig instanceof Signal) {
      return valueOrSig;
    } else {
      return new Signal(valueOrSig);
    }
  }
  static withoutInitialValue() {
    return new Signal(undefined, false);
  }
  bump() {
    assert(this.hasValue || this.hasException);
    for (let link of this.linksOut) {
      link.update(this.hasException, this.valueOrException, link);
    }
  }
  get cur() {
    if (this.hasException) {
      throw this.valueOrException;
    } else if (this.hasValue) {
      return this.valueOrException;
    } else {
      throw new Error('no cur');
    }
  }
  get maybeCur() {
    if (this.hasException) {
      throw this.valueOrException;
    } else {
      return this.valueOrException;
    }
  }
  set(value) {
    if (this.hasException) {
      return;
    }
    if (this.hasValue && this.valueOrException === value) {
      return;
    }
    this.valueOrException = value;
    this.hasValue = true;
    this.bump();
  }
  reject(exception) {
    if (this.hasException) {
      return;
    }
    this.valueOrException = exception;
    this.hasException = true;
    this.hasValue = false;
    this.bump();
    for (let link of this.linksIn) {
      link.kill();
    }
    for (let link of this.linksOut) {
      link.kill();
    }
  }

  [Symbol.asyncIterator]() {
    return new SignalAsyncIterator(this);
  }

  then(t, e) {
    let pr = Promise.withResolvers();
    let stillCreating = true;
    let link = SignalLink.create(this, null, (hasException, valueOrException) => {
      if (stillCreating) {
        return;
      }
      if (hasException) {
        pr.reject(valueOrException);
      } else {
        pr.resolve(valueOrException);
      }
    });
    stillCreating = false;
    return pr.promise.then(t, e);
  }

  map(f) {
    let mappedSignal = new Signal;
    let link = SignalLink.create(this, mappedSignal, (hasException, valueOrException) => {
      if (hasException) {
        mappedSignal.reject(valueOrException);
      } else {
        mappedSignal.set(f(valueOrException));
      }
    });
    return mappedSignal;
  }

  bind(f) {
    let boundSignal = new Signal;
    let forwardingLink = null;
    SignalLink.create(this, boundSignal, (hasException, valueOrException) => {
      if (forwardingLink !== null) {
        forwardingLink.kill();
      }
      if (hasException) {
        boundSignal.reject(valueOrException);
      } else {
        let forwarderSignal = Signal.of(f(valueOrException));
        forwardingLink = SignalLink.create(forwarderSignal, boundSignal, (hasException, valueOrException) => {
          if (hasException) {
            boundSignal.reject(valueOrException);
          } else {
            boundSignal.set(valueOrException);
          }
        });
      }
    });
    return boundSignal;
  }

  hasValueSig() {
    let ret = this.map((_) => true);
    if (!this.hasValue && !this.hasException) {
      ret.set(false);
    }
    return ret;
  }

  kill() {
    this.reject('killed');
  }
}

class SignalAsyncIterator {
  constructor(signal) {
    this.state = 1;
    this.signal = signal;
    this.curPR = null;
    this.link = SignalLink.create(signal, null, (hasException, valueOrException) => {
      if (this.state == -1) {
        this.state = 0;
        let curPR = this.curPR;
        this.curPR = null;
        if (hasException) {
          curPR.reject(valueOrException);
        } else {
          curPR.resolve({done: false, value: valueOrException});
        }
      } else if (this.state == 0) {
        this.state = 1;
      }
    });
  }
  [Symbol.asyncIterator]() { return this; }
  next() {
    if (this.state == 1) {
      this.state = 0;
      if (this.signal.hasException) {
        return Promise.reject(this.signal.valueOrException);
      } else if (this.signal.hasValue) {
        return Promise.resolve({done: false, value: this.signal.valueOrException});
      }
    }
    if (this.state == 0) {
      this.state = -1;
      this.curPR = Promise.withResolvers();
    }
    return this.curPR.promise;
  }
  return(value) {
    this.link.kill();
    console.log('>> return', value);
    return Promise.resolve({value, done: true});
  }
  throw(e) {
    this.link.kill();
    return Promise.resolve({undefined, done: true});
  }
}


class Throttle {
  constructor(name, defaultDelay = 100) {
    this.defaultDelay = defaultDelay;
    this.name = name;
    this.reset();
  }
  reset() {
    this.delay = this.defaultDelay;
  }
  then(f, r) {
    let delay = this.delay;
    this.delay *= 2;
    addStatsLine(`Throttle "${this.name}" waiting for ${delay} ms`);
    return sleep(delay).then(f, r);
  }
}

class WSWrapper {
  constructor(url, delegate) {
    this.wsURL = url;
    this.delegate = delegate;
    this.openThrottle = new Throttle('open');
    this.state = 'idle';
    this.ws = null;
    this.wantOpen = false;
  }
  setWantOpen(wantOpen) {
    this.wantOpen = wantOpen;
    this.openCloseWSAsNeeded();
  }
  kill() {
    if (this.state == 'open') {
      addStatsLine(`closing ${this.wsURL} due to kill`);
      this.ws.close();
    }
    this.state = 'dead';
    this.wantOpen = false;
    this.ws = null;
  }
  openCloseWSAsNeeded() {
    if (this.state == 'idle' && this.wantOpen) {
      this.openWS();
    } else if (this.state == 'open' && !this.wantOpen) {
      addStatsLine(`closing ${this.wsURL}`);
      this.ws.close();
    }
  }
  openWS() {
    assert(this.ws === null);
    assert(this.state == 'idle');
    addStatsLine(`connecting to ${this.wsURL}`);
    let ws = new WebSocket(this.wsURL);
    this.ws = ws;
    this.state = 'connecting';
    ws.binaryType = 'arraybuffer';
    ws.onopen = (e) => {
      assert(this.ws === ws);
      this.state = 'open';
      addStatsLine(`opened connection to ${this.wsURL}`);
      this.delegate.onOpen(e);
      // if it doesn't close quickly, then reset throttle
      setTimeout(() => {
        if (this.ws === ws) {
          this.openThrottle.reset();
        }
      }, 1000);
    };
    ws.onmessage = (e) => {
      assert(this.ws === ws);
      this.delegate.onMessage(e);
    };
    ws.onclose = (e) => {
      assert(this.ws === ws || this.state === 'dead');
      addStatsLine(`closed connection to ${this.wsURL}`);
      this.ws = null;
      if (this.wantOpen) {
        this.state = 'openThrottle';
        (async () => {
          await this.openThrottle;
          this.state = 'idle';
          this.openCloseWSAsNeeded();
        })();
      } else {
        this.state = 'idle';
      }
      this.delegate.onClose(e);
    };
  }
}

let rpcConnClosedMessage = 'RPCConn closed';

class RPCConn {
  constructor(baseURL) {
    mixinKillBox(this);
    this.wsw = this.pushKill(new WSWrapper(`${baseURL}/ws/rpc`, this));
    this.wsw.setWantOpen(true);
    this.rpcThrottle = new Throttle('rpc');
    this.helloInfoPR = this.pushKill(Promise.withResolvers());
    this.isOpenSig = this.pushKill(new Signal(false));
  }
  onOpen(e) {
    this.pendingResponsePRs = [this.helloPendingResponsePR()];
    this.isOpenSig.set(true);
  }
  helloPendingResponsePR() {
    let pr = Promise.withResolvers();
    pr.promise.then((data) => {
      if (typeof data == 'string') {
        this.helloInfoPR.reject(`early error! ${data}`);
        return;
      }
      assert(data instanceof ArrayBuffer);
      this.helloInfoPR.resolve(readHelloModInfo(new Reader(data)));
    }, (reason) => {
      if (reason !== rpcConnClosedMessage) {
        this.helloInfoPR.reject(reason);
      }
    });
    return pr;
  }
  onMessage(e) {
    let pr = this.pendingResponsePRs.shift();
    if (!pr) {
      throw new Error('got unsolicited packet');
    }
    pr.resolve(e.data);
  }
  onClose(e) {
    this.isOpenSig.set(false);
    while (this.pendingResponsePRs.length) {
      let pr = this.pendingResponsePRs.shift();
      pr.reject(rpcConnClosedMessage);
    }
  }
  async rawRequest(req) {
    outerLoop: while (1) {
      while (!this.isOpenSig.cur) {
        addStatsLine('RPC waiting for open');
        await this.isOpenSig;
      }

      //console.log(`sending ${req.byteLength} ${req}`);
      this.wsw.ws.send(req);
      let pr = Promise.withResolvers();
      this.pendingResponsePRs.push(pr);
      let response;
      try {
        response = await pr.promise;
      } catch (e) {
        if (e !== rpcConnClosedMessage) {
          throw e;
        }
        addStatsLine('RPC waiting for re-open');
        continue outerLoop;
      }

      if (typeof response == 'string') {
        addStatsLine(`RPC got error: '${resp}'`);
        await this.rpcThrottle;
        continue outerLoop;
      }

      assert(response instanceof ArrayBuffer);
      this.rpcThrottle.reset();
      //console.log(`RPC got good response: ${response}`);

      return new DataView(response);
    }
  }
  async reqRead(addr, len) {
    let dv = new DataView(new ArrayBuffer(17));
    dv.setInt8(0, 1); // RPC_REQ_READ
    dv.setBigUint64(1, addr, true);
    dv.setBigUint64(9, BigInt(len), true);
    return await this.rawRequest(dv);
  }
  async reqWrite(addr, data) {
    assert(ArrayBuffer.isView(data));
    let headerLen = 9;
    let len = data.byteLength;
    let ab = new ArrayBuffer(headerLen + len);
    new Uint8Array(ab, headerLen).set(new Uint8Array(data.buffer, data.byteOffset, len));
    let dv = new DataView(ab);
    dv.setInt8(0, 2); // RPC_REQ_WRITE
    dv.setBigUint64(1, addr, true);
    let resp = await this.rawRequest(dv);
    assert(resp.byteLength == 8);
    let actual = resp.getBigUint64(0, true);
    assert(actual <= len);
    return [actual, len];
  }
  async reqGetStats() {
    let u8 = Uint8Array.of(3); // RPC_REQ_GET_STATS
    let resp = await this.rawRequest(u8);
    return Reader.with(resp, 0, (r) => ({
      overrunBytes: r.read(ty.u64),
      sentBytes: r.read(ty.u64),
      backpressuredNsec: r.read(ty.u64),
    }));

  }
  async reqSetFlags(clear, set) {
    let dv = new DataView(new ArrayBuffer(17));
    dv.setInt8(0, 4); // RPC_REQ_SET_FLAGS
    dv.setBigUint64(1, clear, true);
    dv.setBigUint64(9, set, true);
    let resp = await this.rawRequest(dv);
    assert(resp.byteLength == 8);
    return resp.getBigUint64(0, true);
  }
}


// --

// --

let svgNS = 'http://www.w3.org/2000/svg';

class DiagramThingKind {
  constructor(diagram) {
    this.diagram = diagram;
    this.mmTypes = diagram.mmTypes;
    this.group = document.createElementNS(svgNS, 'g');
    this.group.setAttribute('kind', this.constructor.name);
    diagram.svg.appendChild(this.group);
    this.elmsByPtr = new Map();
  }
  renderThings() {
    this.genericElmsCount = 0;
    let seen = new Set();
    this.seen = seen;
    for (let thing of this.getThingsFromFrame()) {
      let worldID = this.getWorldID(thing);
      assert(typeof worldID == 'number');
      if (worldID !== this.diagram.worldID) {
        continue;
      }
      this.renderThing(thing);
    }
    for (let elm of Array.from(this.group.children)) {
      if (!this.seen.has(elm)) {
        //console.log(`${this.diagram.curFrame.number}/${this.diagram.curFrame.worldID} removing stale ${elm} at ${elm.ptr} from ${elm.createdFrameNum}`);
        elm.deleteMe();
      }
    }
    this.seen = null;
    //console.log(`now have ${this.group.childElementCount} children`);
  }
  getOrCreateElmFor(ptr, wantedTag) {
    let elm = this.elmsByPtr.get(ptr);
    //console.log(elm);
    if (elm && elm.tagName != wantedTag) {
      elm.deleteMe();
      elm = null;
    }
    if (!elm) {
      elm = document.createElementNS(svgNS, wantedTag);
      assert(elm.tagName == wantedTag);
      //console.log(`creating ${wantedTag}`);
      elm.ptr = ptr;
      elm.createdFrameNum = this.diagram.curFrame.number;
      elm.deleteMe = () => {
        //console.log(`** deleteMe for ${wantedTag} ptr=${ptr}`);
        elm.parentNode.removeChild(elm);
        this.elmsByPtr.delete(ptr);
      };
      this.group.appendChild(elm);
      this.elmsByPtr.set(ptr, elm);
    }
    this.seen.add(elm);
    return elm;
  }

  poly(key, points, {fill = 'none', stroke, strokeWidth}) {
    let dia = this.diagram;
    let stringified = '';
    for (let i = 0, len = points.length; i < len; i += 2) {
      let x = dia.transformX(points[i]);
      let y = dia.transformY(points[i+1]);
      stringified += ` ${x},${y}`;
    }
    let polygon = this.getOrCreateElmFor(key, 'polygon');
    if (polygon._fill === fill &&
        polygon._stroke === stroke &&
        polygon._strokeWidth === strokeWidth &&
        polygon.getAttribute('points') === stringified) {
      return;
    }
    polygon.setAttribute('points', stringified);
    polygon.setAttribute('fill', fill);
    if (stroke !== undefined) {
      polygon.setAttribute('stroke', stroke);
      polygon.setAttribute('stroke-width', strokeWidth);
      polygon.setAttribute('stroke-linejoin', 'bevel');
    }
    polygon._fill = fill;
    polygon._stroke = stroke;
    polygon._strokeWidth = strokeWidth;
  }

  line(key, x1, y1, x2, y2, {stroke, strokeWidth}) {
    let dia = this.diagram;
    let line = this.getOrCreateElmFor(key, 'line');
    let tx1 = dia.transformX(x1);
    let tx2 = dia.transformX(x2);
    let ty1 = dia.transformY(y1);
    let ty2 = dia.transformY(y2);
    if (line.tx1 === tx1 &&
        line.tx2 === tx2 &&
        line.ty1 === ty1 &&
        line.ty2 === ty2 &&
        line.stroke === stroke &&
        line.strokeWidth === strokeWidth) {
      return;
    }
    line.setAttribute('x1', tx1);
    line.setAttribute('y1', ty1);
    line.setAttribute('x2', tx2);
    line.setAttribute('y2', ty2);
    line.setAttribute('stroke', stroke);
    line.setAttribute('stroke-width', strokeWidth);

    line.tx1 = tx1;
    line.tx2 = tx2;
    line.ty1 = ty1;
    line.ty2 = ty2;
    line.stroke = stroke;
    line.strokeWidth = strokeWidth;
  }

  circle(key, cx, cy, r, {fill, stroke, strokeWidth}) {
    let dia = this.diagram;
    let circle = this.getOrCreateElmFor(key, 'circle');
    circle.setAttribute('cx', dia.transformX(cx));
    circle.setAttribute('cy', dia.transformY(cy));
    circle.setAttribute('r', dia.transformSize(r));
    if (fill !== undefined) {
      circle.setAttribute('fill', fill);
    }
    if (stroke !== undefined) {
      circle.setAttribute('stroke', stroke);
      circle.setAttribute('stroke-width', strokeWidth ?? 1);
    }

  }
  rect(key, x, y, width, height, {fill, stroke, strokeWidth}) {
    let dia = this.diagram;
    let rect = this.getOrCreateElmFor(key, 'rect');
    rect.setAttribute('x', dia.transformX(x));
    rect.setAttribute('y', dia.transformY(y));
    rect.setAttribute('width', dia.transformSize(width));
    rect.setAttribute('height', dia.transformSize(height));
    if (fill !== undefined) {
      rect.setAttribute('fill', fill);
    }
    if (stroke !== undefined) {
      rect.setAttribute('stroke', stroke);
      rect.setAttribute('stroke-width', strokeWidth ?? 1);
    }
  }
}

class DiagramHitboxes extends DiagramThingKind {
  getThingsFromFrame() {
    return this.diagram.curFrame.hitboxes.entries();
  }
  getWorldID([ptr, hitbox]) {
    return hitbox.worldID;
  }
  renderThing([ptr, hitbox]) {
    let params = hitbox.params;
    let isCircle = params.isCircle;
    let x = hitbox.rect.min.x;
    let y = hitbox.rect.min.y;
    let w = hitbox.rect.width();
    let h = hitbox.rect.height();

    let dia = this.diagram;
    if (w < 0) {
      // todo: DRY
      return;
    }
    if (isCircle) {
      assert(w == h);
      this.circle(ptr, x + w/2, y + h/2, w/2, {
        stroke: 'green',
        strokeWidth: 4,
        fill: 'yellow',
      });
    } else {
      this.rect(ptr, x, y + h, w, h, {
        stroke: 'green',
        strokeWidth: 4,
        fill: 'yellow',
      });
    }
  }
}

class DiagramNormalColliders extends DiagramThingKind {
  getThingsFromFrame() {
    return this.diagram.curFrame.normalColliders;
  }
  getWorldID(col) {
    return col.worldID;
  }
  renderThing(col) {
    if (col.segmentsCur.length == 0) {
      return;
    }
    let extX = col.extPosCur.x;
    let extY = col.extPosCur.y;
    let dia = this.diagram;
    let points = [];
    let prevSeg = col.segmentsCur[col.segmentsCur.length - 1], seg;
    for (let i = 0, len = col.segmentsCur.length; i < len; i++, prevSeg = seg) {
      seg = col.segmentsCur[i];
      let x1 = seg.rel_pos_1.x;
      let y1 = seg.rel_pos_1.y;
      let x2 = seg.rel_pos_2.x;
      let y2 = seg.rel_pos_2.y;
      if (x1 != prevSeg.rel_pos_2.x ||
          y1 != prevSeg.rel_pos_2.y) {
        return this.renderAsLines(col);
      }
      points.push(x1 + extX, y1 + extY, x2 + extX, y2 + extY);
    }
    this.poly(
      col.ptr,
      points,
      this.myStroke
    );
  }
  renderAsLines(col) {
    let extX = col.extPosCur.x;
    let extY = col.extPosCur.y;
    let dia = this.diagram;
    for (let i = 0; i < col.segmentsCur.length; i++) {
      let seg = col.segmentsCur[i];
      let fakePtr = col.ptr + BigInt(i);
      this.line(
        col.ptr + BigInt(i),
        seg.rel_pos_1.x + extX,
        seg.rel_pos_1.y + extY,
        seg.rel_pos_2.x + extX,
        seg.rel_pos_2.y + extY,
        this.myStroke
      );
    }
  }
  myStroke = {
    stroke: 'red',
    strokeWidth: 2,
  };
}

class DiagramScolColliders extends DiagramThingKind {
  getThingsFromFrame() {
    return this.diagram.curFrame.scolColliders;
  }
  getWorldID(data) {
    return data.worldID;
  }
  renderThing(data) {
    let dia = this.diagram;
    let scol = data.scol;
    if (1) {
      for (let i = 0; i < 4; i++) {
        let fakePtr = data.ptr + BigInt(i);
        let xxyPtr = scol.xxy_ptrs_cur.get(i);
        if (xxyPtr == 0n) {
          // TODO (2025-09-28): not sure what null here means, might be I
          // forgot something, but I'm getting it
          continue;
        }
        let xxy = scol.readPtrFromWithin(xxyPtr , this.mmTypes.XXY);

        this.line(
          fakePtr,

          xxy.x_left + data.extPosCur.x,
          xxy.y + data.extPosCur.y,
          xxy.x_right + data.extPosCur.x,
          xxy.y + data.extPosCur.y,

          {
            stroke: ['pink', 'green', 'blue', 'orange'][i],
            strokeWidth: 4,
          }
        );
      }
    }
    for (let i = 0; i < 4; i++) {
      let resultListIdx = scol.result_list_idxs_cur.get(i);
      let resultList = scol.result_lists_cur.get(i);
      let result = resultList.get(resultListIdx);
      if (result.valid) {
        //console.log(result.angle);

      }

    }
  }
}

class DiagramBGCollisionPoints extends DiagramThingKind {
  getThingsFromFrame() {
    return this.diagram.curFrame.bgCollisionPointEvents;
  }
  getWorldID(data) {
    return data.worldID;
  }
  renderThing(data) {
    this.circle(
      this.genericElmsCount++,
      data.xy.x,
      data.xy.y,
      3,
      {
        fill: data.ret ? 'red' : 'rgba(0, 0, 0, 0.25)',
      }
    );
  }
}

class DiagramBGCollisionTwoPoints extends DiagramThingKind {
  getThingsFromFrame() {
    return this.diagram.curFrame.bgCollisionTwoPointEvents;
  }
  getWorldID(data) {
    return data.worldID;
  }
  renderThing(data) {
    let hit = data.ret;
    this.line(
      this.genericElmsCount++,
      data.xy1.x,
      data.xy1.y,
      data.xy2.x,
      data.xy2.y,
      {
        stroke: hit ? 'black' : 'rgba(0, 0, 0, 0.25)',
        strokeWidth: 1,
      }
    );
  }
}
class Diagram {
  constructor(svg, mmTypes) {
    mixinKillBox(this);
    this.svg = svg;
    this.mmTypes = mmTypes;

    this.lastRenderedFrame = null;

    this.zoomLevel = 1;
    this.panX = 0;
    this.panY = 400;

    this.lastWheelTimeStamp = 0;
    this.zoomMomentum = 0;
    this.zoomMomentumTimeoutID = null;

    this.kinds = [
      this.hitboxes = new DiagramHitboxes(this),
      this.normalColliders = new DiagramNormalColliders(this),
      this.scolColliders = new DiagramScolColliders(this),
      this.bgCollisionPoints = new DiagramBGCollisionPoints(this),
      this.bgCollisionTwoPoints = new DiagramBGCollisionTwoPoints(this),
    ];
    this.worldID = 0;

    this.pushKillEventListener(this.svg, 'wheel', this.onWheel.bind(this),
                               {passive: false});
    this.pushKillEventListener(this.svg, 'mousedown', this.onMouseDown.bind(this));

    this.onMouseMoveBound = this.onMouseMove.bind(this);
    this.onMouseUpBound = this.onMouseUp.bind(this);
  }
  renderFrame(frame) {
    this.curFrame = frame;
    for (let kind of this.kinds) {
      kind.renderThings();
    }
    this.lastRenderedFrame = frame;
    this.curFrame = null;
  }
  transformX(x) {
    return this.panX + this.transformSize(x);
  }
  transformY(y) {
    return this.panY - this.transformSize(y);
  }
  transformSize(size) {
    return size * this.zoomLevel; // todo: match camera
  }
  untransformX(x) {
    return this.untransformSize(x - this.panX);
  }
  untransformY(y) {
    return this.untransformSize(this.panY - y);
  }
  untransformSize(size) {
    return size / this.zoomLevel;
  }
  kill() {
    this.svg.innerHTML = '';
    this.lastRenderedFrame = null;
  }
  guessIsTrackpad(e) {
    // https://stackoverflow.com/questions/10744645/detect-touchpad-vs-mouse-in-javascript
    // hack...
    return e.deltaMode == 0;
  }
  zoomByAmountKeepingPointConstant(zoomAmount, cursorRealX, cursorRealY) {
    let cursorVirtualX = this.untransformX(cursorRealX), cursorVirtualY = this.untransformY(cursorRealY);
    this.zoomLevel *= zoomAmount;

    // stay centered on the cursor
    this.panX += cursorRealX - this.transformX(cursorVirtualX);
    this.panY += cursorRealY - this.transformY(cursorVirtualY);
  }
  onWheel(e) {
    if (this.lastRenderedFrame === null) {
      return;
    }
    e.preventDefault();
    this.disableZoomMomentum();
    let trackpad = this.guessIsTrackpad(e);
    let shouldZoom = !trackpad || e.ctrlKey;
    if (shouldZoom) {
      
      let zoomAmount = 1 - e.deltaY * (trackpad ? 0.009 : 0.002);
      this.zoomByAmountKeepingPointConstant(zoomAmount, e.offsetX, e.offsetY);

      // momentum
      let dt = e.timeStamp - this.lastWheelTimeStamp;
      this.lastWheelTimeStamp = e.timeStamp;
      if (dt < 100) {
        let speedEstimate = Math.log(zoomAmount) / dt;
        this.zoomMomentum = (this.zoomMomentum * 0.5) + (speedEstimate * 0.5);
      } else {
        this.zoomMomentum = 0;
      }
      if (this.zoomMomentumTimeoutID !== null) {
        clearTimeout(this.zoomMomentumTimeoutID);
      }
      let startTime = document.timeline.currentTime;
      this.zoomMomentumTimeoutID = setTimeout(() => {
        this.zoomMomentumTimeoutID = null;
        this.enableZoomMomentum(startTime, e.offsetX, e.offsetY);
      }, 15);
    } else {
      // pan
      this.panX -= e.deltaX * 0.5;
      this.panY -= e.deltaY * 0.5;
    }

    this.renderFrame(this.lastRenderedFrame);

  }
  enableZoomMomentum(startTime, cursorRealX, cursorRealY) {
    this.disableZoomMomentum();
    if (this.dead || this.lastRenderedFrame === null || Math.abs(this.zoomMomentum) < 0.001) {
      return;
    }
    this.zoomMomentumStartZoomLevel = this.zoomLevel;
    this.zoomMomentumStartPanX = this.panX;
    this.zoomMomentumStartPanY = this.panY;
    this.zoomMomentumStartTime = startTime;
    this.zoomMomentumCursorRealX = cursorRealX;
    this.zoomMomentumCursorRealY = cursorRealY;
    let cb = (endTime) => {
      if (this.dead || this.lastRenderedFrame === null) {
        return;
      }
      this.zoomMomentumRAFID = null;
      let dt = endTime - this.zoomMomentumStartTime;
      // integrate (v * (1 - decay)^t) from 0 to t_0...
      // -> v * ((1 - decay)^t - 1) / log(1 - decay)
      let dtScale = 0.01;
      let decay = 0.8;
      let momentumMultiplier = ((1 - decay) ** (dt * dtScale) - 1) / Math.log(1 - decay);
      let amount = (this.zoomMomentum / dtScale) * momentumMultiplier;
      let multiplier = Math.exp(amount);



      //let avgSpeed = amount / dt;
      //console.log(`dt=${dt * dtScale} / avgSpeed=${avgSpeed} momentum=${this.zoomMomentum} mm=${momentumMultiplier}`);
      if (dt * dtScale >= 5) {
        // done
        this.zoomMomentumRAFID = null;
        return;
      }


      this.zoomLevel = this.zoomMomentumStartZoomLevel;
      this.panX = this.zoomMomentumStartPanX;
      this.panY = this.zoomMomentumStartPanY;
      this.zoomByAmountKeepingPointConstant(multiplier, this.zoomMomentumCursorRealX, this.zoomMomentumCursorRealY);

      this.renderFrame(this.lastRenderedFrame);

      this.zoomMomentumRAFID = requestAnimationFrame(cb);
    };
    cb(document.timeline.currentTime);
  }
  disableZoomMomentum() {
    if (this.zoomMomentumRAFID !== null) {
      cancelAnimationFrame(this.zoomMomentumRAFID);
      this.zoomMomentumRAFID = null;
    }
  }
  onMouseDown(e) {
    if (this.lastRenderedFrame === null) {
      return;
    }
    this.disableZoomMomentum();
    this.mouseDownClientX = e.clientX;
    this.mouseDownClientY = e.clientY;
    window.addEventListener('mousemove', this.onMouseMoveBound);
    window.addEventListener('mouseup', this.onMouseUpBound);
    e.preventDefault();
  }
  onMouseUp(e) {
    this.onMouseMove(e);
    this.removeMouseMoveUp();
  }
  onMouseMove(e) {
    e.preventDefault();
    if (this.lastRenderedFrame === null) {
      return;
    }
    this.panX += e.clientX - this.mouseDownClientX;
    this.panY += e.clientY - this.mouseDownClientY;

    this.mouseDownClientX = e.clientX;
    this.mouseDownClientY = e.clientY;

    this.renderFrame(this.lastRenderedFrame);
  }

  removeMouseMoveUp() {
    window.removeEventListener('mousemove', this.onMouseMoveBound);
    window.removeEventListener('mouseup', this.onMouseUpBound);
  }

  kill() {
    this.removeMouseMoveUp();
  }
};

class Scrubbable {
  constructor(diagram, scrubberRow) {
    mixinKillBox(this);
    this.diagram = diagram;
    this.scrubber = scrubberRow.querySelector('#scrubber');

    this.scrubberDisplay = scrubberRow.querySelector('#scrubber-display');

    this.onChangeOrInput = this.onChangeOrInput.bind(this);
    this.pushKillEventListener(this.scrubber, 'change', this.onChangeOrInput.bind(this));
    this.pushKillEventListener(this.scrubber, 'input', this.onChangeOrInput.bind(this));
    this.pushKillEventListener(this.scrubber, 'wheel', this.onWheel.bind(this),
                               {passive: false});

    this.frameIdx = 0;
    this.framesLength = 0;
    this.updateFrames([]);
  }
  onChangeOrInput() {
    let oldFrameIdx = this.frameIdx;
    this.frameIdx = this.frames.length <= 1 ? 0 : parseInt(this.scrubber.value);
    this.framesLength = this.frames.length;
    this.updateRender();
  }
  onWheel(e) {
    if (e.deltaX == 0) {
      return;
    }
    e.preventDefault();
    console.log(e);
  }
  updateRender(oldFrameIdx) {
    let text;
    if (this.framesLength == 0) {
      text = '0/0';
    } else {
      if (this.frameIdx !== oldFrameIdx) {
        this.diagram.renderFrame(this.frames[this.frameIdx]);
      }
      text = `${this.frameIdx + 1}/${this.framesLength}`;
    }
    this.scrubberDisplay.textContent = text;
  }
  updateFrames(frames) {
    if (this.dead) {
      return;
    }
    let oldFrameIdx = this.frameIdx;
    if (this.frameIdx >= this.framesLength - 1) {
      this.frameIdx = frames.length - 1;
    }
    this.frames = frames;
    this.framesLength = frames.length;
    if (frames.length <= 1) {
      // since min=max=value doesn't show as filled, fake it
      this.scrubber.min = -1;
      this.scrubber.max = 0;
      this.scrubber.value = 0;
      this.scrubber.disabled = true;
    } else {
      this.scrubber.min = 0;
      this.scrubber.max = frames.length - 1;
      this.scrubber.value = this.frameIdx;
      this.scrubber.disabled = false;
    }
    this.updateRender(oldFrameIdx);
  }
}

function readableToArrayAsync(readable) {
  // This one-liner is enough in Chrome but not Safari for some reason:
  // return Array.fromAsync(readable);

  let reader = readable.getReader();
  let ai = {[Symbol.asyncIterator]() { return { next() { return reader.read(); }}; }};
  return Array.fromAsync(ai);
}

async function compressBufs(bufs) {
  let compression = new CompressionStream('gzip');
  let compressedBufs = readableToArrayAsync(compression.readable);
  let writer = compression.writable.getWriter();
  for (let buf of bufs) {
    await writer.write(buf);
  }
  await writer.close();
  let cb = await compressedBufs;
  let file = new Blob(cb);
  let url = await new Promise((resolve, reject) => {
    const reader = Object.assign(new FileReader(), {
      onload: () => resolve(reader.result),
      onerror: () => reject(reader.error),
    });
    reader.readAsDataURL(file);
  });
  return url;
}

async function decompressBuf(url) {
  let buf = await (await fetch(url)).arrayBuffer();
  let decompression = new DecompressionStream('gzip');
  let decompressedBufs = readableToArrayAsync(decompression.readable);
  let writer = decompression.writable.getWriter();
  await writer.write(buf);
  await writer.close();
  let db = await decompressedBufs;
  let length = 0;
  for (let dbuf of db) {
    length += dbuf.byteLength;
  }
  let total = new ArrayBuffer(length);
  let offset = 0;
  for (let dbuf of db) {
    let u8 = new Uint8Array(total, offset, dbuf.byteLength);
    u8.set(new Uint8Array(dbuf));
    offset += dbuf.byteLength;
  }
  return total;
}

async function stringifyWithArrayBuffers(data) {
  let curOffset = 0;
  let bufs = [];
  let bufToStr = new Map;
  let json = JSON.stringify(data, (key, obj) => {
    if (obj instanceof ArrayBuffer) {
      let str = bufToStr.get(obj);
      if (str === undefined) {
        bufs.push(obj);
        str = `\x01${curOffset},${obj.byteLength}`;
        curOffset += obj.byteLength;
        bufToStr.set(obj, str);
      }
      return str;
    }
    return obj;
  });
  return json + '\n' + await compressBufs(bufs);
}

async function parseWithArrayBuffers(jsonPlus) {
  let [json, url] = jsonPlus.split('\n');
  let raw = await decompressBuf(url);
  let strToBuf = new Map;
  return JSON.parse(json, (key, obj) => {
    // silly in-band signaling
    if (typeof obj == 'string' && obj[0] === '\x01') {
      let ab = strToBuf.get(obj);
      if (ab === undefined) {
        let [offset, length] = obj.substr(1).split(',');
        offset |= 0;
        length |= 0;
        ab = new ArrayBuffer(length);
        new Uint8Array(ab).set(new Uint8Array(raw, offset, length));
        strToBuf.set(obj, ab);
      }
      return ab;
    }
    return obj;
  });
}


class NormalCollider {
}

class HoseFrame {
  constructor(number) {
    this.number = number;
    this.hitboxes = new Map();
    this.relevantHoseMessages = [];
    this.normalColliders = [];
    this.scolColliders = [];
    this.bgCollisionPointEvents = [];
    this.bgCollisionTwoPointEvents = [];
    this.hitboxCollisionEvents = [];
  }
  toString() {
    return `frame[${this.number}]`;
  }

  save(isFirst) {
    let relevantHoseMessages = this.relevantHoseMessages;
    if (isFirst) {
      relevantHoseMessages = [this.relevantHoseMessages[0]];
      for (let data of this.normalColliders) {
        if (data.firstSeenFrameNumber !== this.number) {
          relevantHoseMessages.push(data.rawData);
        }
      }
      relevantHoseMessages.push(...this.relevantHoseMessages.slice(1));
    }
    return {
      number: this.number,
      relevantHoseMessages,
    }
  }

  static loadInto(frameInfo, hoseParser) {
    for (let [i, buffer] of frameInfo.relevantHoseMessages.entries()) {
      let tag = hoseParser.parse(buffer);
      if (i == 0) {
        assert(tag == 'do_many');
        hoseParser.curFrame.number = frameInfo.number;
      }
    }
  }

  static async loadFramesInto(frames, hoseParser) {
    for (let [i, frame] of frames.entries()) {
      hoseParser.dontUpdateDiagram = i != frames.length - 1;
      HoseFrame.loadInto(frame, hoseParser);
      await yieldMe();
    }
    hoseParser.finalizeFrame();
  }
};

class HoseParser {
  constructor(mmTypes, scrubbable) {
    this.mmTypes = mmTypes;
    this.scrubbable = scrubbable;

    this.savedFrames = [];
    this.curFrame = new HoseFrame(0);

    this.normalColliderMap = new Map();
    this.scolColliderMap = new Map();

    this.tagStats = {};

    this.dontUpdateDiagram = false;
  }
  parse(buffer) {
    assert(buffer instanceof ArrayBuffer);
    let r = new Reader(buffer);
    let tag = r.read(ty.tag8);

    this.tagStats[tag] ??= [0, 0];
    this.tagStats[tag][0] += r.size; // total length
    this.tagStats[tag][1]++; // message count

    let bufferToSave = null;

    switch (tag) {
    case 'collisi':
      this.parseCollision(r);
      break;
    case 'do_many':
      this.parseDoMany(r);
      break;
    case 'hitbox':
      this.parseHitbox(r);
      break;
    case 'normco+':
    case 'normco*':
      this.parseNormalCollider(r);
      break;
    case 'normco-':
      this.parseNormalColliderGone(r);
      break;
    case 'scolcol':
      this.parseScolCollider(r);
      break;
    case 'scolco~':
      bufferToSave = this.parseHashedScolCollider(r);
      break;
    case 'bgcol2p':
      this.parseBGCollisionTwoPoint(r);
      break;
    case 'bgcol1p':
      this.parseBGCollisionPoint(r);
      break;
    case 'overrun':
      this.parseOverrun(r);
      break;
    default:
      addStatsLine(`hose message with unknown tag ${JSON.stringify(tag)}`);
    }
    r.expectEnd();

    if (bufferToSave === null) {
      // either not scol, or parseScolCollider returned null
      bufferToSave = buffer;
    }
    assert(bufferToSave instanceof ArrayBuffer);
    this.curFrame.relevantHoseMessages.push(bufferToSave);

    //console.log(`hose message ${new BigUint64Array(e.data)}`);
    return tag;
  }

  finalizeFrame() {
    for (let data of this.normalColliderMap.values()) {
      if (data.firstSeenFrameNumber !== this.curFrame.number) {
        this.curFrame.normalColliders.push(data);
      }
    }

    let oldFrame = this.curFrame;
    this.savedFrames.push(oldFrame);
    if (!this.dontUpdateDiagram) {
      this.scrubbable.updateFrames(this.savedFrames);
    }
    this.curFrame = new HoseFrame(oldFrame.number + 1);
  }

  parseDoMany(r) {
    let areaSys = r.read(ty.u64);
    let worldID = r.read(ty.u64);
    if (worldID == 0) {
      this.finalizeFrame();
    };
  }
  parseCollision(r) {
    let hb1 = r.read(ty.u64);
    let hb2 = r.read(ty.u64);
    let ret = r.read(ty.u64);
    let data = {
      hb1: this.curFrame.hitboxes.get(hb1),
      hb2: this.curFrame.hitboxes.get(hb2),
      ret: ret,
    }
    if (hb1) {
      data.worldID = data.hb1.worldID;
    } else if (hb2) {
      data.worldID = data.hb2.worldID;
    } else {
      data.worldID = -1;
    }
    this.curFrame.hitboxCollisionEvents.push(data);
  }
  parseHitbox(r) {
    let ptr = r.read(ty.u64);
    let hb = r.read(this.mmTypes.Hitbox, r.remaining() - 1);
    hb.worldID = r.read(ty.s8);
    this.curFrame.hitboxes.set(ptr, hb);
  }
  parseNormalCollider(r) {
    let data = new NormalCollider;
    Object.assign(data, {
      ptr: r.read(ty.u64),
      col: r.read(this.mmTypes.Collider, 0x3e0),
      extPosCur: r.read(this.mmTypes.Point2D),
      extPosOld: r.read(this.mmTypes.Point2D),
      firstSeenFrameNumber: this.curFrame.number,
      segmentsCur: [],
      segmentsOld: [],
      rawData: r.dv.buffer,
    });
    for (let i = 0, count = data.col.segments_cur.count; i < count; i++) {
      data.segmentsCur.push(r.read(this.mmTypes.ColliderSegment));
    }
    for (let i = 0, count = data.col.segments_old.count; i < count; i++) {
      data.segmentsOld.push(r.read(this.mmTypes.ColliderSegment));
    }
    data.worldID = r.read(ty.s8);
    this.normalColliderMap.set(data.ptr, data);
    this.curFrame.normalColliders.push(data);
  }
  parseNormalColliderGone(r) {
    let ptr = r.read(ty.u64);
    this.normalColliderMap.delete(ptr);
  }
  parseScolCollider(r) {
    let data = {
      ptr: r.read(ty.u64),
      scol: r.read(this.mmTypes.Scol, 0x103c),
      extPosCur: r.read(this.mmTypes.Point2D),
      extPosOld: r.read(this.mmTypes.Point2D),
      worldID: r.read(ty.s8),
      originalMessage: r.dv.buffer,
    };
    data.scol._ptr = data.ptr;
    this.scolColliderMap.set(data.ptr, data);
    this.curFrame.scolColliders.push(data);
  }
  parseHashedScolCollider(r) {
    let ptr = r.read(ty.u64);
    let data = this.scolColliderMap.get(ptr);
    if (data !== undefined) {
      this.curFrame.scolColliders.push(data);
      // return the message that needs to be saved if we save to file
      return data.originalMessage;
    } else {
      // this could happen right when connecting
      addStatsLine(`!! missing scol for ${ptr}`);
      return null;
    }
  }
  parseBGCollisionTwoPoint(r) {
    let data = {
      worldID: r.read(ty.u8),
      xy1: r.read(this.mmTypes.Point2D),
      xy2: r.read(this.mmTypes.Point2D),
      shapemask: r.read(ty.u32),
      enable1: r.read(ty.u8),
      enable2: r.read(ty.u8),
      ret: r.read(ty.u8),
      cp: r.read(this.mmTypes.CollisionPoint),
    };
    data.bic = data.cp.bic;
    this.curFrame.bgCollisionTwoPointEvents.push(data);
  }
  parseBGCollisionPoint(r) {
    let data = {
      worldID: r.read(ty.u8),
      xy: r.read(this.mmTypes.Point2D),
      enable1: r.read(ty.u8),
      enable2: r.read(ty.u8),
      ret: r.read(ty.u8),
      bic: r.read(this.mmTypes.CollisionBIC),
    };
    this.curFrame.bgCollisionPointEvents.push(data);
  }
  parseOverrun(r) {
    document.getElementById('overrun').innerHTML = 'got overrun!';
  }
}

class HoseConn {
  constructor(baseURL, hoseParserPromise) {
    this.wsw = new WSWrapper(`${baseURL}/ws/hose`, this);
    this.wsw.setWantOpen(true);
    this.hoseParserPromise = hoseParserPromise;
  }
  onOpen(e) {
  }
  async onMessage(e, wsw) {
    (await this.hoseParserPromise).parse(e.data);
  }
  onClose(e) {
  }
  kill() {
    this.wsw.kill();
  }
}

g_exportJsonPromise = (async () => {
  return await (await fetch('../exlaunch/build/export.json')).json();
})();

/*
class ButtonWrapper
  constructor(button, onClick) {
    this.onClick = onClick;
    this.button = button;
    button.addEventListener('click', onClick);
  }
  kill() {
    this.button.removeEventListener('click', this.onClick);
  }
}
*/

class BaseConns {
  constructor(hash) {
    mixinKillBox(this);
    location.hash = hash;
    this.hoseParserPromise = this.doHoseParser();
    this.mmTypesPromise = this.doMMTypes();
    this.stillAlivePR = this.pushKill(Promise.withResolvers());
    this.loadingSig = this.pushKill(new Signal(true));
  }

  async doHoseParser() {
    await yieldMe();
    let mmTypes = await this.mmTypesPromise;
    let diagram = this.pushKill(new Diagram(document.getElementById('diagram'), mmTypes));
    this.diagram = diagram; // mostly for debugging
    let scrubbable = this.pushKill(new Scrubbable(diagram, document.getElementById('scrubber-row')));
    this.scrubbable = scrubbable; // ditto
    let parser = new HoseParser(mmTypes, scrubbable);
    this._hoseParser = parser; // ditto
    return parser;
  }

  async doMMTypes() {
    await yieldMe();
    let [helloInfo, exportJson] = await Promise.any([
      Promise.all([this.helloInfoPromise, g_exportJsonPromise]),
      this.stillAlivePR.promise,
    ]);
    return new MMTypes(helloInfo, exportJson);
  }

  async saveRaw(nframes) {
    let savedFrames = (await this.hoseParserPromise).savedFrames;
    savedFrames = savedFrames.slice(-nframes);
    if (savedFrames.length && savedFrames[0].number == 0) {
      savedFrames.shift();
    }
    return {
      frames: savedFrames.map((f, i) => f.save(i == 0)),
      helloInfo: (await this.helloInfoPromise).rawData,
    }
  }
  async save(nframes) {
    return await stringifyWithArrayBuffers(await this.saveRaw(nframes));
  }
}

function addStatsLine(text) {
  let div = document.createElement('div');
  div.textContent = text;
  let parent = document.getElementById('stats');
  parent.insertBefore(div, parent.firstChild);
  while (parent.childElementCount > 10) {
    parent.removeChild(parent.lastChild);
  }
}

class LiveConns extends BaseConns {
  constructor(baseURL) {
    super('live');
    mixinKillBox(this);
    this.baseURL = baseURL;

    this.rpc = this.pushKill(new RPCConn(baseURL));
    this.helloInfoPromise = this.rpc.helloInfoPR.promise;

    this.hose = this.pushKill(new HoseConn(baseURL, this.hoseParserPromise));

    document.getElementById('controls-left').removeAttribute('inert');

    this.pushCatchKill(this.doStats());
    this.pushCatchKill(this.doCheckboxes());

    this.loadingSig.set(false);
  }
  async doStats() {
    let lastFrameNum = 0;
    while (!this.dead) {
      if (this.rpc.isOpen) {
        let stats = await this.rpc.reqGetStats();
        let hoseParser = await this.hoseParserPromise;
        let frame = hoseParser.curFrame;
        let frames = frame.number - lastFrameNum;
        lastFrameNum = frame.number;
        let text = `stats: overrunBytes=${stats.overrunBytes} sentBytes=${stats.sentBytes} bp=${stats.backpressuredNsec} frames=${frames} tagStats=${JSON.stringify(hoseParser.tagStats)}\n`
        addStatsLine(text);
        hoseParser.tagStats = {};
      }
      await sleep(1000);
    }
  }

  async updateFlags() {
    let flags = [
      ['controls-backpressure', 1n],
      ['controls-bg-events', 4n],
    ];
    let allFlagVals = 0n;
    let setFlagVals = 0n;
    for (let [flagName, flagVal] of flags) {
      allFlagVals |= flagVal;
      if (document.getElementById(flagName).checked) {
        setFlagVals |= flagVal;
      }
    }
    await this.rpc.reqSetFlags(allFlagVals & ~setFlagVals, setFlagVals);
  }

  async doCheckboxes() {
    let checkedPR = Promise.withResolvers();
    for (let input of document.querySelectorAll('#controls input[type=checkbox]')) {
      input.checked = localStorage[input.id] === '1';
      input.onchange = (e) => {
        localStorage[input.id] = input.checked ? '1' : '0';
        checkedPR.resolve();
      }
    }
    while (1) {
      await Promise.any([
        Promise.all([
          checkedPR,
          this.rpc.openedCond,
        ]),
        this.stillAlivePR.promise,
      ]);
      await this.updateFlags();
    }
  }
}

class LoadedConns extends BaseConns {
  constructor(savedText) {
    super('loaded');
    this.helloInfoPR = Promise.withResolvers();
    this.helloInfoPromise = this.helloInfoPR.promise;

    document.getElementById('controls-left').setAttribute('inert', '');
    addStatsLine('loading...');
    this.loadStartTime = new Date().getTime();

    this.load(savedText);
  }
  async load(savedText) {
    let stuff = await parseWithArrayBuffers(savedText);
    await this.loadRaw(stuff);
    let loadTime = new Date().getTime() - this.loadStartTime;
    addStatsLine(`loaded in ${loadTime}ms.`);
    this.loadingSig.set(false);
  }
  async loadRaw({frames, helloInfo}) {
    this.helloInfoPR.resolve(readHelloModInfo(new Reader(helloInfo)));
    let hoseParser = await this.hoseParserPromise;
    await HoseFrame.loadFramesInto(frames, hoseParser);
  }

}

function jsMemCallback() {
  let text;
  try {
    let mem = performance.memory.usedJSHeapSize / 1048576;
    text = Math.floor(mem);
  } catch (e) {
    document.getElementById('js-mem-container').style.display = 'none';
    return;
  }
  document.getElementById('js-mem').textContent = text;
}
setInterval(jsMemCallback, 2000);
jsMemCallback();

function testSignals() {
  let sig = new Signal;
  let moresigs = [new Signal, new Signal];
  let sig3 = sig.bind(i => moresigs[i]).map(x => x * 2);
  (async () => {
    for await (let val of sig3) {
      console.log(val);
    }
  })();
  sig.set(0);
  moresigs[0].set(42);
  moresigs[0].set(43);
  sig.set(1);
  moresigs[0].set('ignore me');
  moresigs[1].set(44);
  console.log('*', sig3.cur);
}

function mixinKillBox(obj) {
  obj._killCallbacks = [];
  obj.dead = false;
  let superKill = obj.kill;
  obj.pushKill = function(objToKill) {
    if (objToKill.kill !== undefined) {
      this._killCallbacks.push(objToKill.kill.bind(objToKill));
    } else if (objToKill.reject !== undefined) {
      this._killCallbacks.push(() => {
        objToKill.reject(`rejected by KillBox of ${this.constructor.name}`);
      });
    } else {
      throw new Error('not sure how to clean this up');
    }
    return objToKill;
  };
  obj.pushCatchKill = function(promise) {
    promise.then(null, (exception) => {
      if (this.dead && exception == 'killed') {
        // ignore
        console.log('caught killed exception'); 
        return;
      }
      throw exception; // devtools will catch if open
    });
  };
  obj.pushKillEventListener = function(target, event, callback, options) {
    target.addEventListener(event, callback, options);
    this._killCallbacks.push(() => {
      target.removeEventListener(event, callback, options);
    });
  };
  obj.kill = function() {
    if (this.dead) {
      return;
    }
    this.dead = true;
    if (superKill !== undefined) {
      superKill.call(this);
    }
    for (let cb of this._killCallbacks) {
      cb();
    }
    this._killCallbacks = null;
  };
}
class ButtonWrapper {
  constructor(id, {enabled}) {
    mixinKillBox(this);
    this.elm = document.getElementById(id);
    assert(this.elm && this.elm.tagName == 'BUTTON');
    this.clicks = this.pushKill(Signal.withoutInitialValue());
    this.pushKillEventListener(this.elm, 'click', this.onClick.bind(this));
    this.pushKill(Signal.of(enabled).map(e => {
      this.elm.disabled = !e;
    }));
  }
  onClick() {
    this.clicks.set((this.clicks.maybeCur ?? 0) + 1);
  }
}

class UI {
  constructor(connsSig) {
    mixinKillBox(this);
    this.notLoadingSig = connsSig.bind(conns =>
      !conns ? true : conns.loadingSig.map(loading => !loading));

    this.pushKill(this.pushKill(new ButtonWrapper('load-button', {
      enabled: new Signal(true),//this.notLoadingSig,
    })).clicks.map(() => {
      connsSig.maybeCur?.kill();
      connsSig.set(new LoadedConns(localStorage.zw));
    }));

    this.pushKill(this.pushKill(new ButtonWrapper('live-button', {
      enabled: true,
    })).clicks.map(async () => {
      g_connsSig.maybeCur?.kill();
      g_connsSig.set(new LiveConns('ws://neb-solidus:8000'));
    }));

    this.pushKill(this.pushKill(new ButtonWrapper('disconnect-button', {
      enabled: true,
    })).clicks.map(async () => {
      g_connsSig.maybeCur?.kill();
    }));

    this.pushKill(this.pushKill(new ButtonWrapper('save-button', {
      enabled: this.notLoadingSig,
    })).clicks.map(async () => {
      addStatsLine('saving...');
      localStorage.zw = await connsSig.cur.save();
      addStatsLine('saved.');
    }));
  }
}

g_connsSig = new Signal(null);
g_ui = new UI(g_connsSig);


function loadByHash() {
  if (location.hash.length < 2) {
    return;
  }
  let hash = location.hash.substr(1);
  if (hash == 'live') {
    document.getElementById('live-button').click();
  } else if (hash == 'loaded') {
    // todo: more than one save
    document.getElementById('load-button').click();
  }
}
loadByHash();

</script>
